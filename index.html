<!DOCTYPE html><!DOCTYPE html><!DOCTYPE html>

<html lang="pt-BR">

<head><html lang="pt-BR"><html lang="pt-BR">

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0"><head><head>

    <title>üèõÔ∏è Labirinto de Creta</title>

    <style>    <meta charset="UTF-8">    <meta charset="UTF-8">

        * { margin: 0; padding: 0; box-sizing: border-box; }

            <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta name="viewport" content="width=device-width, initial-scale=1.0">

        body {

            font-family: 'Arial', sans-serif;    <title>üèõÔ∏è Labirinto de Creta - O Desafio do Minotauro</title>    <title>Labirinto de Creta - O Desafio do Minotauro</title>

            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);

            color: #fff;    <meta name="description" content="Escape do labirinto sem ser capturado pelo Minotauro implac√°vel!">    <link rel="stylesheet" href="style.css">

            overflow: hidden;

            height: 100vh;    <style>    <link rel="stylesheet" href="telas.css">

        }

        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Poppins:wght@300;400;600&display=swap');    <meta name="description" content="Escape do labirinto sem ser capturado pelo Minotauro implac√°vel!">

        .screen {

            position: fixed;</head>

            top: 0; left: 0; width: 100%; height: 100%;

            display: none;        * {<body>

            justify-content: center;

            align-items: center;            margin: 0;    <!-- TELA PRINCIPAL DE MENU -->

            background: rgba(0,0,0,0.9);

        }            padding: 0;    <div id="tela-menu" class="overlay active">



        .screen.active { display: flex; }            box-sizing: border-box;        <div class="menu-container">



        .menu {        }            <div class="logo-section">

            text-align: center;

            background: rgba(26,26,46,0.95);                <h1 class="game-title">üèõÔ∏è LABIRINTO DE CRETA</h1>

            padding: 3rem;

            border-radius: 20px;        body {                <p class="game-subtitle">O Desafio do Minotauro</p>

            border: 2px solid rgba(255,215,0,0.3);

            box-shadow: 0 20px 40px rgba(0,0,0,0.5);            font-family: 'Poppins', sans-serif;            </div>

        }

            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);            

        .title {

            font-size: 2.5rem;            color: #fff;            <div class="menu-buttons">

            color: #ffd700;

            margin-bottom: 1rem;            overflow: hidden;                <button id="btn-iniciar" class="menu-btn primary">

            text-shadow: 0 0 20px rgba(255,215,0,0.5);

        }            min-height: 100vh;                    üéÆ INICIAR JOGO



        .btn {        }                </button>

            display: block;

            width: 100%;                <button id="btn-continuar" class="menu-btn secondary" style="display: none;">

            padding: 15px;

            margin: 10px 0;        /* ANIMA√á√ïES */                    ‚ñ∂Ô∏è CONTINUAR

            border: none;

            border-radius: 8px;        @keyframes titleGlow {                </button>

            font-size: 1.1rem;

            cursor: pointer;            0% {                 <button id="btn-configuracoes" class="menu-btn secondary">

            transition: all 0.3s;

            text-transform: uppercase;                text-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);                    ‚öôÔ∏è CONFIGURA√á√ïES

        }

                transform: scale(1);                </button>

        .btn-primary {

            background: linear-gradient(135deg, #ff6b6b, #ee5a24);            }                <button id="btn-creditos" class="menu-btn secondary">

            color: white;

        }            50% {                     üë• CR√âDITOS



        .btn-primary:hover {                text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.5);                </button>

            transform: translateY(-2px);

            box-shadow: 0 8px 25px rgba(255,107,107,0.6);                transform: scale(1.02);                <button id="btn-ajuda" class="menu-btn secondary">

        }

            }                    ‚ùì COMO JOGAR

        .btn-secondary {

            background: rgba(255,255,255,0.1);            100% {                 </button>

            color: #fff;

            border: 2px solid rgba(255,255,255,0.2);                text-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);            </div>

        }

                transform: scale(1);            

        .btn-secondary:hover {

            background: rgba(255,255,255,0.2);            }            <div class="version-info">

            border-color: #ffd700;

        }        }                <span>Vers√£o 2.0 - Sistema Completo</span>



        .game-container {            </div>

            position: relative;

            width: 100%;        @keyframes fadeInUp {        </div>

            height: 100vh;

            display: flex;            from {    </div>

            flex-direction: column;

            align-items: center;                opacity: 0;

            justify-content: center;

        }                transform: translateY(30px);    <!-- TELA DO JOGO -->



        .hud {            }    <div id="tela-jogo" class="overlay">

            position: fixed;

            top: 0;            to {        <div id="game-container">

            left: 0;

            right: 0;                opacity: 1;            <!-- HUD Principal -->

            background: rgba(0,0,0,0.8);

            padding: 1rem;                transform: translateY(0);            <div id="hud" class="game-hud">

            display: flex;

            justify-content: space-between;            }                <div class="hud-section left">

            align-items: center;

            z-index: 10;        }                    <div class="hud-item">

        }

                        <span class="hud-label">N√≠vel:</span>

        .hud-item {

            display: flex;        @keyframes buttonHover {                        <span id="level" class="hud-value">1</span>

            flex-direction: column;

            align-items: center;            0% { transform: translateY(0) scale(1); }                    </div>

        }

            50% { transform: translateY(-2px) scale(1.02); }                    <div class="hud-item">

        .hud-label {

            font-size: 0.8rem;            100% { transform: translateY(0) scale(1); }                        <span class="hud-label">Tempo:</span>

            color: #aaa;

            text-transform: uppercase;        }                        <span id="time" class="hud-value">00:00</span>

        }

                    </div>

        .hud-value {

            font-size: 1.2rem;        /* OVERLAY SYSTEM */                </div>

            color: #ffd700;

            font-weight: bold;        .overlay {                

        }

            position: fixed;                <div class="hud-section center">

        #gameCanvas {

            border: 3px solid rgba(255,215,0,0.3);            top: 0;                    <button id="btn-pausa" class="hud-btn">‚è∏Ô∏è PAUSA</button>

            border-radius: 10px;

            box-shadow: 0 0 30px rgba(0,0,0,0.5);            left: 0;                </div>

        }

            width: 100%;                

        .message {

            position: fixed;            height: 100%;                <div class="hud-section right">

            top: 50%;

            left: 50%;            display: none;                    <div class="hud-item">

            transform: translate(-50%, -50%);

            background: rgba(0,0,0,0.9);            justify-content: center;                        <span class="hud-label">Fio:</span>

            padding: 2rem;

            border-radius: 10px;            align-items: center;                        <span id="fio" class="hud-value fio-status">OFF</span>

            border: 2px solid #ffd700;

            z-index: 1000;            z-index: 100;                    </div>

            text-align: center;

        }            backdrop-filter: blur(10px);                    <div class="hud-item">



        .message.hidden { display: none; }            background: rgba(0, 0, 0, 0.9);                        <span class="hud-label">Estado:</span>



        .help {        }                        <span id="minotaur-status" class="hud-value minotaur-status">üü¢</span>

            text-align: left;

            max-width: 600px;                    </div>

            line-height: 1.6;

        }        .overlay.active {                </div>



        .help h3 { color: #ffd700; margin: 1rem 0 0.5rem; }            display: flex;            </div>

        .help p { margin-bottom: 0.5rem; }

        kbd {        }

            background: #444;

            padding: 2px 6px;            <!-- Canvas do Jogo -->

            border-radius: 3px;

            font-family: monospace;        /* MENU PRINCIPAL */            <canvas id="gameCanvas" width="800" height="600"></canvas>

        }

    </style>        .menu-container {

</head>

<body>            text-align: center;            <!-- Mensagem Tempor√°ria -->

    <!-- MENU PRINCIPAL -->

    <div id="menu" class="screen active">            padding: 2rem;            <div id="game-message" class="message-overlay hidden">

        <div class="menu">

            <h1 class="title">üèõÔ∏è LABIRINTO DE CRETA</h1>            border-radius: 20px;                <div class="message-content">

            <p style="margin-bottom: 2rem; color: #aaa;">O Desafio do Minotauro</p>

                        background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));                    <p id="message-text">Bem-vindo ao Labirinto!</p>

            <button class="btn btn-primary" onclick="startGame()">

                üéÆ INICIAR JOGO            border: 2px solid rgba(255, 215, 0, 0.3);                </div>

            </button>

            <button class="btn btn-secondary" onclick="showHelp()">            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);            </div>

                ‚ùì COMO JOGAR

            </button>            animation: fadeInUp 1s ease-out;        </div>

            

            <p style="margin-top: 2rem; color: #666; font-size: 0.9rem;">            max-width: 500px;    </div>

                Vers√£o √önica - Sistema Integrado

            </p>        }

        </div>

    </div>    <!-- TELA DE PAUSA -->



    <!-- TELA DO JOGO -->        .game-title {    <div id="tela-pausa" class="overlay">

    <div id="game" class="screen">

        <div class="game-container">            font-family: 'Cinzel', serif;        <div class="pause-container">

            <div class="hud">

                <div class="hud-item">            font-size: 3rem;            <h2>‚è∏Ô∏è JOGO PAUSADO</h2>

                    <span class="hud-label">N√≠vel</span>

                    <span id="level" class="hud-value">1</span>            font-weight: 700;            <div class="pause-stats">

                </div>

                <div class="hud-item">            color: #ffd700;                <div class="stat-item">

                    <span class="hud-label">Tempo</span>

                    <span id="time" class="hud-value">00:00</span>            margin-bottom: 0.5rem;                    <span>Tempo decorrido:</span>

                </div>

                <div class="hud-item">            animation: titleGlow 2s ease-in-out infinite;                    <span id="pause-tempo">00:00</span>

                    <span class="hud-label">Fio</span>

                    <span id="fio" class="hud-value">OFF</span>        }                </div>

                </div>

                <div class="hud-item">                <div class="stat-item">

                    <span class="hud-label">Minotauro</span>

                    <span id="status" class="hud-value">üü¢</span>        .game-subtitle {                    <span>N√≠vel atual:</span>

                </div>

                <button class="btn btn-secondary" onclick="pauseGame()" style="padding: 8px 16px;">            font-size: 1.2rem;                    <span id="pause-nivel">1</span>

                    ‚è∏Ô∏è PAUSA

                </button>            color: #aaa;                </div>

            </div>

            margin-bottom: 2rem;            </div>

            <canvas id="gameCanvas" width="800" height="600"></canvas>

            font-style: italic;            <div class="pause-buttons">

            <div id="message" class="message hidden">

                <p id="messageText">Bem-vindo!</p>        }                <button id="btn-continuar-jogo" class="menu-btn primary">‚ñ∂Ô∏è CONTINUAR</button>

            </div>

        </div>                <button id="btn-reiniciar-nivel" class="menu-btn secondary">üîÑ REINICIAR N√çVEL</button>

    </div>

        .menu-buttons {                <button id="btn-configuracoes-pausa" class="menu-btn secondary">‚öôÔ∏è CONFIGURA√á√ïES</button>

    <!-- TELA DE PAUSA -->

    <div id="pause" class="screen">            display: flex;                <button id="btn-menu-principal" class="menu-btn danger">üè† MENU PRINCIPAL</button>

        <div class="menu">

            <h2>‚è∏Ô∏è JOGO PAUSADO</h2>            flex-direction: column;            </div>

            <p style="margin: 2rem 0;">

                Tempo: <span id="pauseTime">00:00</span><br>            gap: 1rem;        </div>

                N√≠vel: <span id="pauseLevel">1</span>

            </p>            margin-bottom: 2rem;    </div>

            <button class="btn btn-primary" onclick="resumeGame()">

                ‚ñ∂Ô∏è CONTINUAR        }

            </button>

            <button class="btn btn-secondary" onclick="backToMenu()">    <!-- TELA DE DERROTA -->

                üè† MENU PRINCIPAL

            </button>        .menu-btn {    <div id="tela-derrota" class="overlay">

        </div>

    </div>            padding: 15px 30px;        <div class="result-container defeat">



    <!-- TELA DE AJUDA -->            border: none;            <div class="result-icon">üíÄ</div>

    <div id="help" class="screen">

        <div class="menu help">            border-radius: 10px;            <h2>VOC√ä FOI CAPTURADO!</h2>

            <h2>‚ùì COMO JOGAR</h2>

                        font-size: 1.1rem;            <p class="result-message">O Minotauro conseguiu te alcan√ßar...</p>

            <h3>üéØ OBJETIVO</h3>

            <p>Escape do labirinto encontrando a sa√≠da verde (üö™) sem ser capturado pelo Minotauro vermelho (üêÇ)!</p>            font-weight: 600;            

            

            <h3>üïπÔ∏è CONTROLES</h3>            cursor: pointer;            <div class="stats-grid">

            <p><kbd>WASD</kbd> ou <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> - Mover Teseu</p>

            <p><kbd>ESPA√áO</kbd> - Ativar/Desativar Fio de Ariadne</p>            transition: all 0.3s ease;                <div class="stat-card">

            <p><kbd>ESC</kbd> - Pausar/Despausar jogo</p>

                        text-transform: uppercase;                    <div class="stat-number" id="derrota-tempo">--:--</div>

            <h3>üßµ FIO DE ARIADNE</h3>

            <p>‚Ä¢ Marca seu caminho com uma linha dourada</p>        }                    <div class="stat-label">Tempo Sobrevivido</div>

            <p>‚Ä¢ Te ajuda a n√£o se perder no labirinto</p>

            <p>‚Ä¢ Ative/desative conforme necess√°rio</p>                </div>

            

            <h3>üêÇ MINOTAURO</h3>        .menu-btn.primary {                <div class="stat-card">

            <p>üü¢ Verde: Patrulhando normalmente</p>

            <p>üî¥ Vermelho: Te viu e est√° perseguindo!</p>            background: linear-gradient(135deg, #ff6b6b, #ee5a24);                    <div class="stat-number" id="derrota-passos">0</div>

            

            <h3>üí° DICAS</h3>            color: white;                    <div class="stat-label">Passos Dados</div>

            <p>‚Ä¢ Use as paredes para quebrar linha de vis√£o</p>

            <p>‚Ä¢ O Minotauro nunca desiste da persegui√ß√£o</p>            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);                </div>

            <p>‚Ä¢ Seja r√°pido mas cauteloso!</p>

                    }                <div class="stat-card">

            <button class="btn btn-primary" onclick="backToMenu()" style="margin-top: 2rem;">

                üîô VOLTAR AO MENU                    <div class="stat-number" id="derrota-nivel">1</div>

            </button>

        </div>        .menu-btn.primary:hover {                    <div class="stat-label">N√≠vel Alcan√ßado</div>

    </div>

            transform: translateY(-3px);                </div>

    <script>

        // ===========================            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);            </div>

        // SISTEMA COMPLETO EM UM S√ì ARQUIVO

        // ===========================            animation: buttonHover 0.6s ease;            



        // Estado do jogo        }            <div class="result-buttons">

        const game = {

            level: 1,                <button id="btn-tentar-novamente" class="menu-btn primary">üîÑ TENTAR NOVAMENTE</button>

            time: 0,

            state: 'menu',        .menu-btn.secondary {                <button id="btn-menu-derrota" class="menu-btn secondary">üè† MENU PRINCIPAL</button>

            maze: null,

            player: null,            background: rgba(255, 255, 255, 0.1);            </div>

            minotaur: null,

            fioActive: false,            color: #fff;        </div>

            seed: Date.now()

        };            border: 2px solid rgba(255, 255, 255, 0.2);    </div>



        // Canvas        }

        let canvas, ctx;

        let lastTime = 0;    <!-- TELA DE VIT√ìRIA -->

        let animationId = null;

        .menu-btn.secondary:hover {    <div id="tela-vitoria" class="overlay">

        // Input

        const input = {            background: rgba(255, 255, 255, 0.2);        <div class="result-container victory">

            up: false, down: false, left: false, right: false,

            space: false, spacePressed: false            border-color: #ffd700;            <div class="result-icon">üèÜ</div>

        };

            transform: translateY(-2px);            <h2>N√çVEL COMPLETADO!</h2>

        // ===========================

        // GERADOR DE LABIRINTO        }            <p class="result-message">Voc√™ escapou do Minotauro com sucesso!</p>

        // ===========================

        class Maze {            

            constructor(size, seed = 12345) {

                this.size = Math.max(15, Math.min(size || 21, 31));        .version-info {            <div class="stats-grid">

                if (this.size % 2 === 0) this.size++;

                            color: #666;                <div class="stat-card">

                this.seed = seed;

                this.rng = this.seededRandom(seed);            font-size: 0.9rem;                    <div class="stat-number" id="vitoria-tempo">--:--</div>

                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(1));

                        }                    <div class="stat-label">Tempo Completado</div>

                this.generate();

                this.findStartEnd();                </div>

            }

                    /* GAME CONTAINER */                <div class="stat-card">

            seededRandom(seed) {

                let state = seed;        #game-container {                    <div class="stat-number" id="vitoria-eficiencia">0%</div>

                return () => {

                    state = (state * 1664525 + 1013904223) % Math.pow(2, 32);            position: relative;                    <div class="stat-label">Efici√™ncia</div>

                    return state / Math.pow(2, 32);

                };            width: 100%;                </div>

            }

                        height: 100vh;                <div class="stat-card">

            generate() {

                const stack = [];            display: flex;                    <div class="stat-number" id="vitoria-pontuacao">0</div>

                let current = { x: 1, y: 1 };

                this.grid[1][1] = 0;            flex-direction: column;                    <div class="stat-label">Pontua√ß√£o</div>

                

                while (true) {            align-items: center;                </div>

                    const neighbors = this.getUnvisitedNeighbors(current);

                                justify-content: center;            </div>

                    if (neighbors.length > 0) {

                        const next = neighbors[Math.floor(this.rng() * neighbors.length)];        }            

                        stack.push(current);

                                    <div class="result-buttons">

                        const wallX = current.x + (next.x - current.x) / 2;

                        const wallY = current.y + (next.y - current.y) / 2;        .game-hud {                <button id="btn-proximo-nivel" class="menu-btn primary">‚û°Ô∏è PR√ìXIMO N√çVEL</button>

                        

                        this.grid[wallY][wallX] = 0;            position: fixed;                <button id="btn-menu-vitoria" class="menu-btn secondary">üè† MENU PRINCIPAL</button>

                        this.grid[next.y][next.x] = 0;

                                    top: 0;            </div>

                        current = next;

                    } else if (stack.length > 0) {            left: 0;        </div>

                        current = stack.pop();

                    } else {            right: 0;    </div>

                        break;

                    }            background: rgba(0, 0, 0, 0.8);

                }

            }            padding: 1rem;    <!-- TELA DE CONFIGURA√á√ïES -->

            

            getUnvisitedNeighbors(cell) {            display: flex;    <div id="tela-configuracoes" class="overlay">

                const neighbors = [];

                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];            justify-content: space-between;        <div class="config-container">

                

                for (const [dx, dy] of directions) {            align-items: center;            <h2>‚öôÔ∏è CONFIGURA√á√ïES</h2>

                    const nx = cell.x + dx;

                    const ny = cell.y + dy;            z-index: 10;            

                    

                    if (nx > 0 && nx < this.size - 1 && ny > 0 && ny < this.size - 1 && this.grid[ny][nx] === 1) {            border-bottom: 2px solid rgba(255, 215, 0, 0.3);            <div class="config-section">

                        neighbors.push({ x: nx, y: ny });

                    }        }                <h3>üéÆ Jogabilidade</h3>

                }

                                <div class="config-item">

                return neighbors;

            }        .hud-section {                    <label>Dificuldade:</label>

            

            findStartEnd() {            display: flex;                    <select id="config-dificuldade">

                this.start = { x: 1, y: 1 };

                this.exit = { x: this.size - 2, y: this.size - 2 };            gap: 2rem;                        <option value="facil">üòä F√°cil</option>

                this.minotaurStart = { x: Math.floor(this.size / 2), y: Math.floor(this.size / 2) };

            }            align-items: center;                        <option value="normal" selected>üòê Normal</option>

            

            get(x, y) {        }                        <option value="dificil">üò∞ Dif√≠cil</option>

                if (x < 0 || x >= this.size || y < 0 || y >= this.size) return 1;

                return this.grid[y][x];                        <option value="pesadelo">üíÄ Pesadelo</option>

            }

                    .hud-item {                    </select>

            isWalkable(x, y) {

                return this.get(Math.floor(x), Math.floor(y)) === 0;            display: flex;                </div>

            }

        }            flex-direction: column;                



        // ===========================            align-items: center;                <div class="config-item">

        // JOGADOR

        // ===========================            gap: 0.2rem;                    <label>Semente do Mapa:</label>

        class Player {

            constructor(startCell) {        }                    <div class="seed-controls">

                this.x = startCell.x + 0.5;

                this.y = startCell.y + 0.5;                        <input type="number" id="config-semente" placeholder="Deixe vazio para aleat√≥rio">

                this.speed = 4.0;

                this.trail = [];        .hud-label {                        <button id="btn-gerar-semente" class="small-btn">üé≤</button>

                this.lastMoveTime = 0;

            }            font-size: 0.8rem;                    </div>

            

            update(deltaTime, input, maze) {            color: #aaa;                </div>

                const moveSpeed = this.speed * deltaTime / 1000;

                let newX = this.x;            text-transform: uppercase;            </div>

                let newY = this.y;

                let moved = false;        }            

                

                if (input.up) { newY -= moveSpeed; moved = true; }            <div class="config-section">

                if (input.down) { newY += moveSpeed; moved = true; }

                if (input.left) { newX -= moveSpeed; moved = true; }        .hud-value {                <h3>üîä √Åudio</h3>

                if (input.right) { newX += moveSpeed; moved = true; }

                            font-size: 1.2rem;                <div class="config-item">

                if (maze.isWalkable(newX, this.y)) this.x = newX;

                if (maze.isWalkable(this.x, newY)) this.y = newY;            font-weight: 600;                    <label>Volume Geral:</label>

                

                if (game.fioActive && moved) {            color: #ffd700;                    <input type="range" id="config-volume" min="0" max="100" value="70">

                    const now = Date.now();

                    if (now - this.lastMoveTime > 100) {        }                    <span id="volume-display">70%</span>

                        this.trail.push({ x: this.x, y: this.y });

                        this.lastMoveTime = now;                </div>

                        if (this.trail.length > 500) this.trail.shift();

                    }        .hud-btn {                

                }

            }            padding: 8px 16px;                <div class="config-item">

        }

            border: none;                    <label>

        // ===========================

        // MINOTAURO            border-radius: 6px;                        <input type="checkbox" id="config-som-passos" checked>

        // ===========================

        class Minotaur {            background: rgba(255, 107, 107, 0.8);                        Sons de passos

            constructor(startCell) {

                this.x = startCell.x + 0.5;            color: white;                    </label>

                this.y = startCell.y + 0.5;

                this.speed = 2.0;            cursor: pointer;                </div>

                this.chaseSpeed = 3.5;

                this.state = 'patrol';            transition: all 0.3s ease;            </div>

                this.sightRange = 8;

                this.lastPlayerPos = null;        }            

                this.patrolTarget = null;

                this.chaseTime = 0;            <div class="config-section">

            }

                    .hud-btn:hover {                <h3>üé® Visual</h3>

            update(deltaTime, player, maze) {

                const dt = deltaTime / 1000;            background: #ff6b6b;                <div class="config-item">

                

                if (this.canSeePlayer(player, maze)) {            transform: scale(1.05);                    <label>Qualidade Gr√°fica:</label>

                    this.state = 'chase';

                    this.lastPlayerPos = { x: player.x, y: player.y };        }                    <select id="config-qualidade">

                    this.chaseTime = 5000;

                } else if (this.chaseTime > 0) {                        <option value="baixa">üì± Baixa</option>

                    this.chaseTime -= deltaTime;

                    if (this.chaseTime <= 0) this.state = 'patrol';        #gameCanvas {                        <option value="media" selected>üíª M√©dia</option>

                }

                            border: 3px solid rgba(255, 215, 0, 0.3);                        <option value="alta">üñ•Ô∏è Alta</option>

                if (this.state === 'chase' && this.lastPlayerPos) {

                    this.moveTowards(this.lastPlayerPos, this.chaseSpeed * dt, maze);            border-radius: 10px;                    </select>

                } else {

                    this.patrol(dt, maze);            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);                </div>

                }

                        }                

                this.updateStatus();

            }                <div class="config-item">

            

            canSeePlayer(player, maze) {        .message-overlay {                    <label>

                const dx = player.x - this.x;

                const dy = player.y - this.y;            position: fixed;                        <input type="checkbox" id="config-animacoes" checked>

                const distance = Math.sqrt(dx * dx + dy * dy);

                            top: 50%;                        Anima√ß√µes suaves

                if (distance > this.sightRange) return false;

                            left: 50%;                    </label>

                const steps = Math.ceil(distance * 2);

                for (let i = 0; i <= steps; i++) {            transform: translate(-50%, -50%);                </div>

                    const checkX = this.x + (dx * i / steps);

                    const checkY = this.y + (dy * i / steps);            background: rgba(0, 0, 0, 0.9);            </div>

                    

                    if (maze.get(Math.floor(checkX), Math.floor(checkY)) === 1) {            padding: 2rem;            

                        return false;

                    }            border-radius: 10px;            <div class="config-buttons">

                }

                            border: 2px solid #ffd700;                <button id="btn-aplicar-config" class="menu-btn primary">‚úÖ APLICAR</button>

                return true;

            }            z-index: 1000;                <button id="btn-resetar-config" class="menu-btn secondary">üîÑ RESETAR</button>

            

            moveTowards(target, speed, maze) {            text-align: center;                <button id="btn-fechar-config" class="menu-btn secondary">‚ùå FECHAR</button>

                const dx = target.x - this.x;

                const dy = target.y - this.y;            animation: fadeInUp 0.5s ease;            </div>

                const distance = Math.sqrt(dx * dx + dy * dy);

                        }        </div>

                if (distance > 0.1) {

                    const moveX = (dx / distance) * speed;    </div>

                    const moveY = (dy / distance) * speed;

                            .message-overlay.hidden {

                    if (maze.isWalkable(this.x + moveX, this.y)) this.x += moveX;

                    if (maze.isWalkable(this.x, this.y + moveY)) this.y += moveY;            display: none;    <!-- TELA DE CR√âDITOS -->

                }

            }        }    <div id="tela-creditos" class="overlay">

            

            patrol(dt, maze) {        <div class="credits-container">

                if (!this.patrolTarget || this.reachedTarget()) {

                    this.pickNewPatrolTarget(maze);        /* PAUSE SCREEN */            <h2>üë• CR√âDITOS</h2>

                }

                        .pause-container {            

                if (this.patrolTarget) {

                    this.moveTowards(this.patrolTarget, this.speed * dt, maze);            text-align: center;            <div class="credits-section">

                }

            }            padding: 3rem;                <h3>üéÆ Desenvolvimento</h3>

            

            pickNewPatrolTarget(maze) {            background: rgba(26, 26, 46, 0.95);                <p><strong>Programa√ß√£o:</strong> GitHub Copilot & Assistant</p>

                for (let i = 0; i < 50; i++) {

                    const x = Math.random() * maze.size;            border-radius: 20px;                <p><strong>Game Design:</strong> Sistema de IA Avan√ßada</p>

                    const y = Math.random() * maze.size;

                                border: 2px solid rgba(255, 215, 0, 0.3);                <p><strong>Arte & Interface:</strong> Design Responsivo Moderno</p>

                    if (maze.isWalkable(x, y)) {

                        this.patrolTarget = { x, y };            min-width: 400px;            </div>

                        break;

                    }        }            

                }

            }            <div class="credits-section">

            

            reachedTarget() {        .pause-stats {                <h3>üèõÔ∏è Inspira√ß√£o Mitol√≥gica</h3>

                if (!this.patrolTarget) return true;

                const dx = this.patrolTarget.x - this.x;            margin: 2rem 0;                <p><strong>Baseado na lenda grega do:</strong></p>

                const dy = this.patrolTarget.y - this.y;

                return Math.sqrt(dx * dx + dy * dy) < 0.5;            display: flex;                <p>Labirinto de Creta e o Minotauro</p>

            }

                        justify-content: space-around;                <p><strong>Personagens:</strong> Teseu, Minotauro, Ariadne</p>

            updateStatus() {

                const statusEl = document.getElementById('status');        }            </div>

                if (statusEl) {

                    statusEl.textContent = this.state === 'chase' ? 'üî¥' : 'üü¢';            

                }

            }        .stat-item {            <div class="credits-section">

        }

            display: flex;                <h3>üîß Tecnologias</h3>

        // ===========================

        // INPUT            flex-direction: column;                <p><strong>Engine:</strong> JavaScript Vanilla + Canvas</p>

        // ===========================

        document.addEventListener('keydown', (e) => {            align-items: center;                <p><strong>IA:</strong> Sistema de Pathfinding A*</p>

            switch(e.code) {

                case 'KeyW': case 'ArrowUp': input.up = true; break;            gap: 0.5rem;                <p><strong>Interface:</strong> CSS3 + Anima√ß√µes</p>

                case 'KeyS': case 'ArrowDown': input.down = true; break;

                case 'KeyA': case 'ArrowLeft': input.left = true; break;        }            </div>

                case 'KeyD': case 'ArrowRight': input.right = true; break;

                case 'Space':            

                    e.preventDefault();

                    if (!input.spacePressed) {        .pause-buttons {            <div class="credits-section">

                        input.space = true;

                        input.spacePressed = true;            display: flex;                <h3>üéµ Reconhecimentos</h3>

                    }

                    break;            flex-direction: column;                <p>Algoritmos de gera√ß√£o procedural de labirintos</p>

                case 'Escape':

                    e.preventDefault();            gap: 1rem;                <p>Sistema de vis√£o e persegui√ß√£o por IA</p>

                    if (game.state === 'playing') {

                        pauseGame();        }                <p>Interface moderna e responsiva</p>

                    } else if (game.state === 'paused') {

                        resumeGame();            </div>

                    }

                    break;        .menu-btn.danger {            

            }

        });            background: linear-gradient(135deg, #e74c3c, #c0392b);            <div class="credits-buttons">



        document.addEventListener('keyup', (e) => {            color: white;                <button id="btn-voltar-creditos" class="menu-btn primary">üîô VOLTAR</button>

            switch(e.code) {

                case 'KeyW': case 'ArrowUp': input.up = false; break;        }            </div>

                case 'KeyS': case 'ArrowDown': input.down = false; break;

                case 'KeyA': case 'ArrowLeft': input.left = false; break;        </div>

                case 'KeyD': case 'ArrowRight': input.right = false; break;

                case 'Space': input.spacePressed = false; break;        .menu-btn.danger:hover {    </div>

            }

        });            background: linear-gradient(135deg, #c0392b, #a93226);



        // ===========================            transform: translateY(-2px);    <!-- TELA DE AJUDA -->

        // RENDERIZA√á√ÉO

        // ===========================        }    <div id="tela-ajuda" class="overlay">

        function initRenderer() {

            canvas = document.getElementById('gameCanvas');        <div class="help-container">

            if (!canvas) return false;

            ctx = canvas.getContext('2d');        /* RESPONSIVO */            <h2>‚ùì COMO JOGAR</h2>

            return true;

        }        @media (max-width: 768px) {            



        function render() {            .game-title {            <div class="help-section">

            if (!ctx || !game.maze) return;

                            font-size: 2rem;                <h3>üéØ OBJETIVO</h3>

            ctx.fillStyle = '#000';

            ctx.fillRect(0, 0, canvas.width, canvas.height);            }                <p>Escape do labirinto encontrando a sa√≠da (üü©) sem ser capturado pelo Minotauro (üêÇ)!</p>

            

            const cellSize = Math.min(canvas.width / game.maze.size, canvas.height / game.maze.size);                        </div>

            const offsetX = (canvas.width - cellSize * game.maze.size) / 2;

            const offsetY = (canvas.height - cellSize * game.maze.size) / 2;            .menu-container {            

            

            // Labirinto                margin: 1rem;            <div class="help-section">

            for (let y = 0; y < game.maze.size; y++) {

                for (let x = 0; x < game.maze.size; x++) {                padding: 1.5rem;                <h3>üïπÔ∏è CONTROLES</h3>

                    const screenX = offsetX + x * cellSize;

                    const screenY = offsetY + y * cellSize;            }                <div class="controls-grid">

                    

                    if (game.maze.get(x, y) === 1) {                                <div class="control-item">

                        ctx.fillStyle = '#444';

                        ctx.fillRect(screenX, screenY, cellSize, cellSize);            #gameCanvas {                        <kbd>WASD</kbd> ou <kbd>‚Üë‚Üì‚Üê‚Üí</kbd>

                    } else {

                        ctx.fillStyle = '#222';                width: 90vw;                        <span>Mover Teseu</span>

                        ctx.fillRect(screenX, screenY, cellSize, cellSize);

                    }                height: auto;                    </div>

                }

            }            }                    <div class="control-item">

            

            // Sa√≠da                                    <kbd>ESPA√áO</kbd>

            const exitX = offsetX + game.maze.exit.x * cellSize;

            const exitY = offsetY + game.maze.exit.y * cellSize;            .hud-section {                        <span>Ativar/Desativar Fio de Ariadne</span>

            ctx.fillStyle = '#4CAF50';

            ctx.fillRect(exitX, exitY, cellSize, cellSize);                gap: 1rem;                    </div>

            

            // Trail do fio            }                    <div class="control-item">

            if (game.fioActive && game.player.trail.length > 1) {

                ctx.strokeStyle = '#FFD700';        }                        <kbd>ESC</kbd>

                ctx.lineWidth = 3;

                ctx.beginPath();                        <span>Pausar/Despausar</span>

                

                for (let i = 0; i < game.player.trail.length; i++) {        /* Fio de Ariadne - Status */                    </div>

                    const point = game.player.trail[i];

                    const screenX = offsetX + point.x * cellSize;        .fio-status {                </div>

                    const screenY = offsetY + point.y * cellSize;

                                color: #ffd700;            </div>

                    if (i === 0) ctx.moveTo(screenX, screenY);

                    else ctx.lineTo(screenX, screenY);            font-weight: bold;            

                }

                ctx.stroke();        }            <div class="help-section">

            }

                            <h3>üßµ FIO DE ARIADNE</h3>

            // Jogador

            if (game.player) {        .fio-status:before {                <p>‚Ä¢ Marca seu caminho com pontos dourados</p>

                const playerX = offsetX + game.player.x * cellSize;

                const playerY = offsetY + game.player.y * cellSize;            content: "üßµ ";                <p>‚Ä¢ Te ajuda a n√£o se perder no labirinto</p>

                

                ctx.fillStyle = '#2196F3';        }                <p>‚Ä¢ Use com sabedoria para escapar!</p>

                ctx.beginPath();

                ctx.arc(playerX, playerY, cellSize * 0.3, 0, Math.PI * 2);            </div>

                ctx.fill();

            }        /* Minotaur Status */            

            

            // Minotauro        .minotaur-status {            <div class="help-section">

            if (game.minotaur) {

                const minotaurX = offsetX + game.minotaur.x * cellSize;            font-size: 1.5rem;                <h3>üêÇ O MINOTAURO</h3>

                const minotaurY = offsetY + game.minotaur.y * cellSize;

                            transition: all 0.3s ease;                <p>‚Ä¢ Criatura implac√°vel que patrulha o labirinto</p>

                ctx.fillStyle = game.minotaur.state === 'chase' ? '#F44336' : '#FF5722';

                ctx.beginPath();        }                <p>‚Ä¢ <span style="color: #ff4444;">Vermelho escuro:</span> Estado normal de patrulha</p>

                ctx.arc(minotaurX, minotaurY, cellSize * 0.35, 0, Math.PI * 2);

                ctx.fill();                <p>‚Ä¢ <span style="color: #ff0000;">Vermelho brilhante:</span> Te viu e est√° perseguindo!</p>

            }

        }        .minotaur-status.patrol { color: #4CAF50; }                <p>‚Ä¢ Possui vis√£o limitada - use isso a seu favor!</p>



        // ===========================        .minotaur-status.alert { color: #FFC107; }            </div>

        // L√ìGICA DO JOGO

        // ===========================        .minotaur-status.chase { color: #F44336; animation: pulse 1s infinite; }            

        function startLevel(level) {

            console.log(`üèõÔ∏è N√≠vel ${level}`);            <div class="help-section">

            

            game.level = level;        @keyframes pulse {                <h3>‚ö° DICAS DE SOBREVIV√äNCIA</h3>

            game.time = 0;

            game.state = 'playing';            0% { transform: scale(1); }                <p>üèÉ‚Äç‚ôÇÔ∏è <strong>Seja r√°pido mas cauteloso</strong> - Velocidade √© vida!</p>

            game.seed = Date.now() + level;

                        50% { transform: scale(1.2); }                <p>üß± <strong>Use as paredes</strong> - Quebrem a linha de vis√£o</p>

            const size = Math.min(15 + (level - 1) * 2, 31);

            game.maze = new Maze(size, game.seed);            100% { transform: scale(1); }                <p>üëÄ <strong>Observe o estado do Minotauro</strong> - A cor indica o perigo</p>

            game.player = new Player(game.maze.start);

            game.minotaur = new Minotaur(game.maze.minotaurStart);        }                <p>üßµ <strong>Fio de Ariadne</strong> - Seu melhor amigo em labirintos grandes</p>

            

            updateHUD();    </style>                <p>üéØ <strong>Conhe√ßa a sa√≠da</strong> - Sempre saiba onde est√° seu objetivo</p>

            showMessage('Encontre a sa√≠da verde sem ser capturado!');

        }</head>            </div>



        function updateGame(deltaTime) {<body>            

            if (game.state !== 'playing') return;

                <!-- MENU PRINCIPAL -->            <div class="help-buttons">

            game.time += deltaTime;

                <div id="tela-menu" class="overlay active">                <button id="btn-voltar-ajuda" class="menu-btn primary">üîô VOLTAR</button>

            if (input.space) {

                game.fioActive = !game.fioActive;        <div class="menu-container">                <button id="btn-iniciar-tutorial" class="menu-btn secondary">üéÆ COME√áAR A JOGAR</button>

                console.log(`üßµ Fio: ${game.fioActive ? 'ON' : 'OFF'}`);

                input.space = false;            <div class="logo-section">            </div>

            }

                            <h1 class="game-title">üèõÔ∏è LABIRINTO DE CRETA</h1>        </div>

            if (game.player) game.player.update(deltaTime, input, game.maze);

            if (game.minotaur) game.minotaur.update(deltaTime, game.player, game.maze);                <p class="game-subtitle">O Desafio do Minotauro</p>    </div>

            

            checkCollisions();            </div>

            updateHUD();

        }                <!-- SCRIPTS -->



        function checkCollisions() {            <div class="menu-buttons">    <script src="mazeGenerator.js"></script>

            if (!game.player || !game.minotaur) return;

                            <button id="btn-iniciar" class="menu-btn primary">    <script src="MinotaurAI.js"></script>

            const playerCell = {

                x: Math.floor(game.player.x),                    üéÆ INICIAR JOGO    <script src="renderer.js"></script>

                y: Math.floor(game.player.y)

            };                </button>    <script src="main.js"></script>

            

            if (playerCell.x === game.maze.exit.x && playerCell.y === game.maze.exit.y) {                <button id="btn-ajuda" class="menu-btn secondary">    <script src="estados.js"></script>

                game.state = 'won';

                showMessage(`üèÜ N√≠vel ${game.level} completo!`);                    ‚ùì COMO JOGAR    <script src="controles.js"></script>

                setTimeout(() => startLevel(game.level + 1), 3000);

                return;                </button>    <script src="game.js"></script>

            }

                        </div>    

            const dx = game.player.x - game.minotaur.x;

            const dy = game.player.y - game.minotaur.y;                <script>

            const distance = Math.sqrt(dx * dx + dy * dy);

                        <div class="version-info">        // Inicializa√ß√£o

            if (distance < 0.6) {

                game.state = 'lost';                <span>Vers√£o √önica - Sistema Integrado</span>        console.log('üèõÔ∏è Iniciando Labirinto de Creta v2.0');

                showMessage('üíÄ Capturado! Reiniciando...');

                setTimeout(() => startLevel(game.level), 2000);            </div>        

            }

        }        </div>        // Verificar se todos os m√≥dulos carregaram



        function updateHUD() {    </div>        if (typeof mudarEstado === 'function') {

            document.getElementById('level').textContent = game.level;

            document.getElementById('time').textContent = formatTime(game.time);            console.log('‚úÖ Sistema de estados carregado');

            document.getElementById('fio').textContent = game.fioActive ? 'ON' : 'OFF';

        }    <!-- TELA DO JOGO -->            mudarEstado('MENU');



        function formatTime(ms) {    <div id="tela-jogo" class="overlay">        } else {

            const seconds = Math.floor(ms / 1000);

            const minutes = Math.floor(seconds / 60);        <div id="game-container">            console.log('‚ö†Ô∏è Sistema de estados n√£o encontrado, usando fallback');

            const secs = seconds % 60;

            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;            <div class="game-hud">        }

        }

                <div class="hud-section">    </script>

        function showMessage(text) {

            const messageEl = document.getElementById('message');                    <div class="hud-item"></body>

            const textEl = document.getElementById('messageText');

                                    <span class="hud-label">N√≠vel</span></html>

            if (messageEl && textEl) {                        <span id="level" class="hud-value">1</span>

                textEl.textContent = text;                    </div>

                messageEl.classList.remove('hidden');                    <div class="hud-item">

                setTimeout(() => messageEl.classList.add('hidden'), 3000);                        <span class="hud-label">Tempo</span>

            }                        <span id="time" class="hud-value">00:00</span>

        }                    </div>

                </div>

        // ===========================                

        // CONTROLE DE TELAS                <div class="hud-section">

        // ===========================                    <button id="btn-pausa" class="hud-btn">‚è∏Ô∏è PAUSA</button>

        function showScreen(screenId) {                </div>

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));                

            document.getElementById(screenId).classList.add('active');                <div class="hud-section">

        }                    <div class="hud-item">

                        <span class="hud-label">Fio</span>

        function startGame() {                        <span id="fio" class="hud-value fio-status">OFF</span>

            console.log('üéÆ Iniciando jogo...');                    </div>

                                <div class="hud-item">

            if (!initRenderer()) {                        <span class="hud-label">Minotauro</span>

                alert('‚ùå Erro no canvas!');                        <span id="minotaur-status" class="hud-value minotaur-status patrol">üü¢</span>

                return;                    </div>

            }                </div>

                        </div>

            showScreen('game');

            startLevel(1);            <canvas id="gameCanvas" width="800" height="600"></canvas>

            

            if (!animationId) gameLoop(0);            <div id="game-message" class="message-overlay hidden">

        }                <p id="message-text">Bem-vindo ao Labirinto!</p>

            </div>

        function pauseGame() {        </div>

            console.log('‚è∏Ô∏è Pausado');    </div>

            game.state = 'paused';

                <!-- TELA DE PAUSA -->

            document.getElementById('pauseTime').textContent = formatTime(game.time);    <div id="tela-pausa" class="overlay">

            document.getElementById('pauseLevel').textContent = game.level;        <div class="pause-container">

                        <h2>‚è∏Ô∏è JOGO PAUSADO</h2>

            showScreen('pause');            <div class="pause-stats">

        }                <div class="stat-item">

                    <span>Tempo:</span>

        function resumeGame() {                    <span id="pause-tempo">00:00</span>

            console.log('‚ñ∂Ô∏è Retomado');                </div>

            game.state = 'playing';                <div class="stat-item">

            showScreen('game');                    <span>N√≠vel:</span>

        }                    <span id="pause-nivel">1</span>

                </div>

        function backToMenu() {            </div>

            if (animationId) {            <div class="pause-buttons">

                cancelAnimationFrame(animationId);                <button id="btn-continuar-jogo" class="menu-btn primary">‚ñ∂Ô∏è CONTINUAR</button>

                animationId = null;                <button id="btn-menu-principal" class="menu-btn danger">üè† MENU</button>

            }            </div>

            game.state = 'menu';        </div>

            showScreen('menu');    </div>

        }

    <!-- TELA DE AJUDA -->

        function showHelp() {    <div id="tela-ajuda" class="overlay">

            showScreen('help');        <div class="menu-container">

        }            <h2>‚ùì COMO JOGAR</h2>

            <div style="text-align: left; margin: 2rem 0;">

        // ===========================                <h3>üéØ OBJETIVO</h3>

        // LOOP PRINCIPAL                <p>Escape do labirinto (üü©) sem ser capturado pelo Minotauro (üêÇ)!</p>

        // ===========================                <br>

        function gameLoop(currentTime) {                

            const deltaTime = currentTime - lastTime;                <h3>üïπÔ∏è CONTROLES</h3>

            lastTime = currentTime;                <p><kbd>WASD</kbd> ou <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> - Mover</p>

                            <p><kbd>ESPA√áO</kbd> - Ativar/Desativar Fio de Ariadne</p>

            updateGame(deltaTime);                <p><kbd>ESC</kbd> - Pausar jogo</p>

            render();                <br>

                            

            animationId = requestAnimationFrame(gameLoop);                <h3>üêÇ MINOTAURO</h3>

        }                <p>üü¢ Verde: Patrulhando</p>

                <p>üü° Amarelo: Investigando</p>

        // ===========================                <p>üî¥ Vermelho: PERSEGUINDO!</p>

        // INICIALIZA√á√ÉO                <br>

        // ===========================                

        document.addEventListener('DOMContentLoaded', () => {                <h3>üí° DICAS</h3>

            console.log('üèõÔ∏è Labirinto de Creta - Sistema √önico');                <p>‚Ä¢ Use paredes para quebrar linha de vis√£o</p>

            console.log('‚úÖ Clique em INICIAR JOGO para come√ßar!');                <p>‚Ä¢ O Fio de Ariadne ajuda a n√£o se perder</p>

        });                <p>‚Ä¢ Seja r√°pido mas cauteloso!</p>

            </div>

        // Debug            <button id="btn-voltar-ajuda" class="menu-btn primary">üîô VOLTAR</button>

        document.addEventListener('click', (e) => {        </div>

            if (e.target.tagName === 'BUTTON') {    </div>

                console.log(`üñ±Ô∏è Clique: ${e.target.textContent}`);

            }    <script>

        });        // ================================

    </script>        // SISTEMA COMPLETO - ARQUIVO √öNICO

</body>        // ================================

</html>
        // Estado do jogo
        let currentState = 'MENU';
        const game = {
            level: 1,
            time: 0,
            state: 'menu', // 'playing', 'paused', 'won', 'lost'
            maze: null,
            player: null,
            minotaur: null,
            fioActive: false,
            seed: Date.now()
        };

        // Canvas e contexto
        let canvas, ctx;
        let lastTime = 0;
        let animationId = null;

        // ===============================
        // CLASSE MAZE (Gerador de Labirinto)
        // ===============================
        class Maze {
            constructor(size, seed = 12345) {
                this.size = Math.max(15, Math.min(size, 31));
                if (this.size % 2 === 0) this.size++;
                
                this.seed = seed;
                this.rng = this.seededRandom(seed);
                
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(1));
                this.generate();
                this.findStartEnd();
            }
            
            seededRandom(seed) {
                let state = seed;
                return () => {
                    state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                    return (state / Math.pow(2, 32));
                };
            }
            
            generate() {
                const stack = [];
                let current = { x: 1, y: 1 };
                this.grid[1][1] = 0;
                
                while (true) {
                    const neighbors = this.getUnvisitedNeighbors(current);
                    
                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(this.rng() * neighbors.length)];
                        stack.push(current);
                        
                        const wallX = current.x + (next.x - current.x) / 2;
                        const wallY = current.y + (next.y - current.y) / 2;
                        
                        this.grid[wallY][wallX] = 0;
                        this.grid[next.y][next.x] = 0;
                        
                        current = next;
                    } else if (stack.length > 0) {
                        current = stack.pop();
                    } else {
                        break;
                    }
                }
            }
            
            getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                for (const [dx, dy] of directions) {
                    const nx = cell.x + dx;
                    const ny = cell.y + dy;
                    
                    if (nx > 0 && nx < this.size - 1 && ny > 0 && ny < this.size - 1 && this.grid[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                
                return neighbors;
            }
            
            findStartEnd() {
                this.start = { x: 1, y: 1 };
                this.exit = { x: this.size - 2, y: this.size - 2 };
                this.minotaurStart = { x: Math.floor(this.size / 2), y: Math.floor(this.size / 2) };
            }
            
            get(x, y) {
                if (x < 0 || x >= this.size || y < 0 || y >= this.size) return 1;
                return this.grid[y][x];
            }
            
            isWalkable(x, y) {
                return this.get(Math.floor(x), Math.floor(y)) === 0;
            }
        }

        // ===============================
        // CLASSE PLAYER
        // ===============================
        class Player {
            constructor(startCell) {
                this.x = startCell.x + 0.5;
                this.y = startCell.y + 0.5;
                this.speed = 4.0;
                this.trail = [];
                this.lastMoveTime = 0;
            }
            
            update(deltaTime, input, maze) {
                const moveSpeed = this.speed * deltaTime / 1000;
                let newX = this.x;
                let newY = this.y;
                let moved = false;
                
                if (input.up) { newY -= moveSpeed; moved = true; }
                if (input.down) { newY += moveSpeed; moved = true; }
                if (input.left) { newX -= moveSpeed; moved = true; }
                if (input.right) { newX += moveSpeed; moved = true; }
                
                // Verificar colis√µes
                if (maze.isWalkable(newX, this.y)) {
                    this.x = newX;
                }
                if (maze.isWalkable(this.x, newY)) {
                    this.y = newY;
                }
                
                // Adicionar ao trail se o fio estiver ativo e se moveu
                if (game.fioActive && moved) {
                    const now = Date.now();
                    if (now - this.lastMoveTime > 100) { // Trail a cada 100ms
                        this.trail.push({ x: this.x, y: this.y, time: now });
                        this.lastMoveTime = now;
                        
                        // Limitar tamanho do trail
                        if (this.trail.length > 1000) {
                            this.trail.shift();
                        }
                    }
                }
            }
        }

        // ===============================
        // CLASSE MINOTAUR (IA IMPLAC√ÅVEL)
        // ===============================
        class Minotaur {
            constructor(startCell) {
                this.x = startCell.x + 0.5;
                this.y = startCell.y + 0.5;
                this.speed = 2.0;
                this.chaseSpeed = 3.5;
                this.state = 'patrol'; // 'patrol', 'chase'
                this.sightRange = 8;
                this.lastPlayerPos = null;
                this.patrolTarget = null;
                this.chaseTime = 0;
            }
            
            update(deltaTime, player, maze) {
                const dt = deltaTime / 1000;
                
                // Verificar se pode ver o jogador
                if (this.canSeePlayer(player, maze)) {
                    this.state = 'chase';
                    this.lastPlayerPos = { x: player.x, y: player.y };
                    this.chaseTime = 5000; // Perseguir por 5 segundos mesmo se perder de vista
                } else if (this.chaseTime > 0) {
                    this.chaseTime -= deltaTime;
                    if (this.chaseTime <= 0) {
                        this.state = 'patrol';
                    }
                }
                
                // Movimento baseado no estado
                if (this.state === 'chase' && this.lastPlayerPos) {
                    this.moveTowards(this.lastPlayerPos, this.chaseSpeed * dt, maze);
                } else {
                    this.patrol(dt, maze);
                }
                
                // Atualizar status visual
                this.updateStatus();
            }
            
            canSeePlayer(player, maze) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.sightRange) return false;
                
                // Verificar linha de vis√£o
                const steps = Math.ceil(distance * 2);
                for (let i = 0; i <= steps; i++) {
                    const checkX = this.x + (dx * i / steps);
                    const checkY = this.y + (dy * i / steps);
                    
                    if (maze.get(Math.floor(checkX), Math.floor(checkY)) === 1) {
                        return false;
                    }
                }
                
                return true;
            }
            
            moveTowards(target, speed, maze) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0.1) {
                    const moveX = (dx / distance) * speed;
                    const moveY = (dy / distance) * speed;
                    
                    if (maze.isWalkable(this.x + moveX, this.y)) {
                        this.x += moveX;
                    }
                    if (maze.isWalkable(this.x, this.y + moveY)) {
                        this.y += moveY;
                    }
                }
            }
            
            patrol(dt, maze) {
                if (!this.patrolTarget || this.reachedTarget()) {
                    this.pickNewPatrolTarget(maze);
                }
                
                if (this.patrolTarget) {
                    this.moveTowards(this.patrolTarget, this.speed * dt, maze);
                }
            }
            
            pickNewPatrolTarget(maze) {
                // Escolher uma posi√ß√£o aleat√≥ria caminh√°vel
                const attempts = 50;
                for (let i = 0; i < attempts; i++) {
                    const x = Math.random() * maze.size;
                    const y = Math.random() * maze.size;
                    
                    if (maze.isWalkable(x, y)) {
                        this.patrolTarget = { x, y };
                        break;
                    }
                }
            }
            
            reachedTarget() {
                if (!this.patrolTarget) return true;
                
                const dx = this.patrolTarget.x - this.x;
                const dy = this.patrolTarget.y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < 0.5;
            }
            
            updateStatus() {
                const statusEl = document.getElementById('minotaur-status');
                if (statusEl) {
                    statusEl.className = 'hud-value minotaur-status ' + this.state;
                    statusEl.textContent = this.state === 'chase' ? 'üî¥' : 'üü¢';
                }
            }
        }

        // ===============================
        // SISTEMA DE INPUT
        // ===============================
        const input = {
            up: false, down: false, left: false, right: false,
            space: false, spacePressed: false
        };

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': input.up = true; break;
                case 'KeyS': case 'ArrowDown': input.down = true; break;
                case 'KeyA': case 'ArrowLeft': input.left = true; break;
                case 'KeyD': case 'ArrowRight': input.right = true; break;
                case 'Space':
                    e.preventDefault();
                    if (!input.spacePressed) {
                        input.space = true;
                        input.spacePressed = true;
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    if (game.state === 'playing') {
                        pauseGame();
                    } else if (currentState === 'PAUSA') {
                        resumeGame();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': input.up = false; break;
                case 'KeyS': case 'ArrowDown': input.down = false; break;
                case 'KeyA': case 'ArrowLeft': input.left = false; break;
                case 'KeyD': case 'ArrowRight': input.right = false; break;
                case 'Space': input.spacePressed = false; break;
            }
        });

        // ===============================
        // SISTEMA DE RENDERIZA√á√ÉO
        // ===============================
        function initRenderer() {
            canvas = document.getElementById('gameCanvas');
            if (!canvas) return false;
            
            ctx = canvas.getContext('2d');
            return true;
        }

        function render() {
            if (!ctx || !game.maze) return;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = Math.min(canvas.width / game.maze.size, canvas.height / game.maze.size);
            const offsetX = (canvas.width - cellSize * game.maze.size) / 2;
            const offsetY = (canvas.height - cellSize * game.maze.size) / 2;
            
            // Renderizar labirinto
            for (let y = 0; y < game.maze.size; y++) {
                for (let x = 0; x < game.maze.size; x++) {
                    const screenX = offsetX + x * cellSize;
                    const screenY = offsetY + y * cellSize;
                    
                    if (game.maze.get(x, y) === 1) {
                        // Parede
                        ctx.fillStyle = '#444';
                        ctx.fillRect(screenX, screenY, cellSize, cellSize);
                        ctx.strokeStyle = '#666';
                        ctx.strokeRect(screenX, screenY, cellSize, cellSize);
                    } else {
                        // Ch√£o
                        ctx.fillStyle = '#222';
                        ctx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                }
            }
            
            // Renderizar sa√≠da
            const exitX = offsetX + game.maze.exit.x * cellSize;
            const exitY = offsetY + game.maze.exit.y * cellSize;
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(exitX, exitY, cellSize, cellSize);
            ctx.fillStyle = '#000';
            ctx.font = `${cellSize * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('üö™', exitX + cellSize/2, exitY + cellSize*0.7);
            
            // Renderizar trail do fio
            if (game.fioActive && game.player.trail.length > 1) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                
                for (let i = 0; i < game.player.trail.length; i++) {
                    const point = game.player.trail[i];
                    const screenX = offsetX + point.x * cellSize;
                    const screenY = offsetY + point.y * cellSize;
                    
                    if (i === 0) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Renderizar jogador
            if (game.player) {
                const playerX = offsetX + game.player.x * cellSize;
                const playerY = offsetY + game.player.y * cellSize;
                
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.arc(playerX, playerY, cellSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                ctx.font = `${cellSize * 0.4}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('üõ°Ô∏è', playerX, playerY + cellSize * 0.15);
            }
            
            // Renderizar minotauro
            if (game.minotaur) {
                const minotaurX = offsetX + game.minotaur.x * cellSize;
                const minotaurY = offsetY + game.minotaur.y * cellSize;
                
                ctx.fillStyle = game.minotaur.state === 'chase' ? '#F44336' : '#FF5722';
                ctx.beginPath();
                ctx.arc(minotaurX, minotaurY, cellSize * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFF';
                ctx.font = `${cellSize * 0.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('üêÇ', minotaurX, minotaurY + cellSize * 0.18);
            }
        }

        // ===============================
        // L√ìGICA DO JOGO
        // ===============================
        function startLevel(level) {
            console.log(`üèõÔ∏è Iniciando n√≠vel ${level}`);
            
            game.level = level;
            game.time = 0;
            game.state = 'playing';
            game.seed = Date.now() + level;
            
            const size = Math.min(15 + (level - 1) * 2, 31);
            game.maze = new Maze(size, game.seed);
            game.player = new Player(game.maze.start);
            game.minotaur = new Minotaur(game.maze.minotaurStart);
            
            updateHUD();
            showMessage('Encontre a sa√≠da sem ser capturado pelo Minotauro!');
        }

        function updateGame(deltaTime) {
            if (game.state !== 'playing') return;
            
            game.time += deltaTime;
            
            // Verificar input do fio
            if (input.space) {
                game.fioActive = !game.fioActive;
                console.log(`üßµ Fio de Ariadne: ${game.fioActive ? 'ATIVADO' : 'DESATIVADO'}`);
                input.space = false;
            }
            
            // Atualizar entidades
            if (game.player) game.player.update(deltaTime, input, game.maze);
            if (game.minotaur) game.minotaur.update(deltaTime, game.player, game.maze);
            
            // Verificar colis√µes
            checkCollisions();
            
            updateHUD();
        }

        function checkCollisions() {
            if (!game.player || !game.minotaur) return;
            
            // Vit√≥ria - chegada na sa√≠da
            const playerCell = {
                x: Math.floor(game.player.x),
                y: Math.floor(game.player.y)
            };
            
            if (playerCell.x === game.maze.exit.x && playerCell.y === game.maze.exit.y) {
                game.state = 'won';
                showMessage(`üèÜ N√≠vel ${game.level} completo! Pressione ESC para continuar.`);
                setTimeout(() => {
                    startLevel(game.level + 1);
                }, 3000);
                return;
            }
            
            // Derrota - captura pelo Minotauro
            const dx = game.player.x - game.minotaur.x;
            const dy = game.player.y - game.minotaur.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 0.6) {
                game.state = 'lost';
                showMessage('üíÄ Voc√™ foi capturado! Pressione ESC para tentar novamente.');
                setTimeout(() => {
                    startLevel(game.level);
                }, 2000);
            }
        }

        function updateHUD() {
            const levelEl = document.getElementById('level');
            const timeEl = document.getElementById('time');
            const fioEl = document.getElementById('fio');
            
            if (levelEl) levelEl.textContent = game.level;
            if (timeEl) timeEl.textContent = formatTime(game.time);
            if (fioEl) fioEl.textContent = game.fioActive ? 'ON' : 'OFF';
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function showMessage(text) {
            const messageEl = document.getElementById('game-message');
            const textEl = document.getElementById('message-text');
            
            if (messageEl && textEl) {
                textEl.textContent = text;
                messageEl.classList.remove('hidden');
                
                setTimeout(() => {
                    messageEl.classList.add('hidden');
                }, 3000);
            }
        }

        // ===============================
        // SISTEMA DE ESTADOS/TELAS
        // ===============================
        function changeState(newState) {
            console.log(`üîÑ Mudando estado: ${currentState} ‚Üí ${newState}`);
            
            // Esconder todas as telas
            document.querySelectorAll('.overlay').forEach(el => {
                el.classList.remove('active');
            });
            
            // Mostrar tela correspondente
            const targetScreen = document.getElementById(`tela-${newState.toLowerCase()}`);
            if (targetScreen) {
                targetScreen.classList.add('active');
                currentState = newState;
            }
        }

        function startGame() {
            console.log('üéÆ Iniciando jogo...');
            
            if (!initRenderer()) {
                alert('‚ùå Erro ao inicializar canvas!');
                return;
            }
            
            changeState('JOGO');
            startLevel(1);
            
            if (!animationId) {
                gameLoop(0);
            }
        }

        function pauseGame() {
            console.log('‚è∏Ô∏è Pausando jogo...');
            game.state = 'paused';
            
            // Atualizar dados da tela de pausa
            const tempoEl = document.getElementById('pause-tempo');
            const nivelEl = document.getElementById('pause-nivel');
            
            if (tempoEl) tempoEl.textContent = formatTime(game.time);
            if (nivelEl) nivelEl.textContent = game.level;
            
            changeState('PAUSA');
        }

        function resumeGame() {
            console.log('‚ñ∂Ô∏è Retomando jogo...');
            game.state = 'playing';
            changeState('JOGO');
        }

        // ===============================
        // LOOP PRINCIPAL DO JOGO
        // ===============================
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            updateGame(deltaTime);
            render();
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // ===============================
        // EVENT LISTENERS
        // ===============================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üèõÔ∏è Labirinto de Creta - Sistema √önico Carregado');
            
            // Bot√µes do menu
            document.getElementById('btn-iniciar')?.addEventListener('click', startGame);
            document.getElementById('btn-ajuda')?.addEventListener('click', () => changeState('AJUDA'));
            
            // Bot√µes de pausa
            document.getElementById('btn-continuar-jogo')?.addEventListener('click', resumeGame);
            document.getElementById('btn-menu-principal')?.addEventListener('click', () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                game.state = 'menu';
                changeState('MENU');
            });
            document.getElementById('btn-pausa')?.addEventListener('click', pauseGame);
            
            // Bot√£o de voltar da ajuda
            document.getElementById('btn-voltar-ajuda')?.addEventListener('click', () => changeState('MENU'));
            
            console.log('‚úÖ Sistema inicializado - Clique em INICIAR JOGO para come√ßar!');
        });

        // Debug - mostrar cliques
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                console.log(`üñ±Ô∏è Bot√£o clicado: ${e.target.id || e.target.textContent}`);
            }
        });
    </script>
</body>
</html>