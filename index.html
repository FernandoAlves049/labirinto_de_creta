<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèõÔ∏è Labirinto de Creta</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', 'Arial', sans-serif;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 53, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(102, 126, 234, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 60% 60%, rgba(50, 205, 50, 0.15) 0%, transparent 50%),
                linear-gradient(135deg, #1e3a8a 0%, #3b82f6 25%, #06b6d4 50%, #10b981 75%, #f59e0b 100%);
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.8" fill="%23ffd700" opacity="0.4"/><circle cx="12" cy="8" r="0.5" fill="%23fff" opacity="0.3"/><circle cx="18" cy="15" r="0.6" fill="%23ff6b35" opacity="0.2"/><circle cx="5" cy="18" r="0.4" fill="%2367eea" opacity="0.25"/></pattern></defs><rect width="100" height="100" fill="url(%23stars)"/></svg>') repeat;
            pointer-events: none;
            z-index: -1;
            animation: starfield 60s linear infinite;
        }

        @keyframes starfield {
            from { transform: translateY(0px); }
            to { transform: translateY(-100px); }
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            transition: all 0.5s ease-in-out;
        }

        .screen.active {
            display: flex;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Tela de Loading */
        .loading-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 30px;
            padding: 3rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: floatingGlow 4s ease-in-out infinite alternate;
        }

        @keyframes floatingGlow {
            0% { 
                transform: translateY(0px) rotate(0deg);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 30px rgba(255, 215, 0, 0.2);
            }
            100% { 
                transform: translateY(-10px) rotate(0.5deg);
                box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4), 0 0 50px rgba(255, 215, 0, 0.4);
            }
        }

        .logo-loading {
            margin-bottom: 3rem;
            position: relative;
        }

        .logo-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
            display: block;
            animation: iconFloat 3s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
            transform-style: preserve-3d;
        }

        @keyframes iconFloat {
            0%, 100% { 
                transform: translateY(0px) rotateY(0deg);
                text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: translateY(-15px) rotateY(10deg);
                text-shadow: 0 0 50px rgba(255, 215, 0, 1);
            }
        }

        .logo-text {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ff6b35, #f7931e, #ffd700);
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            animation: textShimmer 3s ease-in-out infinite, textGlow 2s ease-in-out infinite alternate;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
        }

        @keyframes textShimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes textGlow {
            from { filter: brightness(1) contrast(1); }
            to { filter: brightness(1.3) contrast(1.1); }
        }

        .loading-bar-container {
            width: 350px;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 15px;
            overflow: hidden;
            margin: 2rem auto;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 4px 20px rgba(255, 215, 0, 0.2);
        }

        .loading-bar-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: scanLine 2s linear infinite;
        }

        @keyframes scanLine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, 
                #ff6b35 0%, 
                #f7931e 25%, 
                #ffd700 50%, 
                #ffed4e 75%, 
                #ffd700 100%
            );
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.5s ease-out;
            animation: progressShimmer 2s linear infinite;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }

        @keyframes progressShimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .loading-text {
            font-size: 1.2rem;
            margin-top: 1rem;
            opacity: 0.8;
        }

        /* Tela de Menu */
        .menu-container {
            text-align: center;
            max-width: 600px;
            padding: 3rem;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 30px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .menu-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(255, 215, 0, 0.1), transparent, rgba(255, 107, 107, 0.1), transparent);
            animation: rotateBackground 20s linear infinite;
            z-index: -1;
        }

        @keyframes rotateBackground {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .menu-header {
            margin-bottom: 3rem;
            position: relative;
        }

        .logo-title {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ff6b35, #f7931e, #ffd700);
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 1rem;
            animation: titlePulse 4s ease-in-out infinite, textShimmer 3s ease-in-out infinite;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            letter-spacing: 3px;
            transform-style: preserve-3d;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1) rotateX(0deg); }
            50% { transform: scale(1.05) rotateX(5deg); }
        }

        .logo-subtitle {
            font-size: 1.4rem;
            font-weight: 400;
            color: #ffd700;
            opacity: 0.9;
            margin-bottom: 2rem;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: subtitleFloat 3s ease-in-out infinite alternate;
            letter-spacing: 1px;
        }

        @keyframes subtitleFloat {
            from { transform: translateY(0px); opacity: 0.9; }
            to { transform: translateY(-5px); opacity: 1; }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            padding: 1.2rem 2.5rem;
            border: none;
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-height: 70px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(20px);
            border: 2px solid transparent;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateY(-5px) scale(1.02);
            filter: brightness(1.1);
        }

        .menu-btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #ff6b35, #f7931e, #ffd700);
            background-size: 200% 200%;
            color: white;
            box-shadow: 
                0 8px 25px rgba(255, 107, 53, 0.4),
                0 4px 15px rgba(247, 147, 30, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.3);
            animation: primaryGlow 3s ease-in-out infinite;
        }

        @keyframes primaryGlow {
            0%, 100% { 
                background-position: 0% 50%;
                box-shadow: 
                    0 8px 25px rgba(255, 107, 53, 0.4),
                    0 4px 15px rgba(247, 147, 30, 0.3),
                    0 0 30px rgba(255, 215, 0, 0.2);
            }
            50% { 
                background-position: 100% 50%;
                box-shadow: 
                    0 12px 35px rgba(255, 107, 53, 0.6),
                    0 6px 20px rgba(247, 147, 30, 0.5),
                    0 0 50px rgba(255, 215, 0, 0.4);
            }
        }

        .menu-btn.primary:hover {
            box-shadow: 
                0 15px 40px rgba(255, 107, 53, 0.6),
                0 8px 25px rgba(247, 147, 30, 0.5),
                0 0 60px rgba(255, 215, 0, 0.5);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            background-size: 200% 200%;
            color: white;
            box-shadow: 
                0 8px 25px rgba(102, 126, 234, 0.4),
                0 4px 15px rgba(118, 75, 162, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.3);
            animation: secondaryGlow 4s ease-in-out infinite;
        }

        @keyframes secondaryGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .menu-btn.secondary:hover {
            box-shadow: 
                0 15px 40px rgba(102, 126, 234, 0.6),
                0 8px 25px rgba(118, 75, 162, 0.5);
        }

        .menu-btn.tertiary {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(30px);
            box-shadow: 
                0 8px 25px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .menu-btn.tertiary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 
                0 15px 40px rgba(255, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .menu-footer {
            font-size: 1rem;
            opacity: 0.8;
            line-height: 1.6;
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 15px;
            backdrop-filter: blur(20px);
        }

        .controls-hint {
            color: #ffd700;
            font-weight: 500;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 5px rgba(255, 215, 0, 0.3);
        }

        .version-info {
            color: #ccc;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Tela de Jogo */
        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(180deg, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(0, 0, 0, 0.7) 70%, 
                transparent 100%
            );
            backdrop-filter: blur(20px);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .game-hud.show {
            opacity: 1;
        }

        .hud-left, .hud-right {
            display: flex;
            gap: 2rem;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.8rem 1.2rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .hud-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        .hud-label {
            font-size: 0.8rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #ccc;
        }

        .hud-value {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1.1rem;
            color: #ffd700;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: valueGlow 2s ease-in-out infinite alternate;
        }

        @keyframes valueGlow {
            from { text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 2px 20px rgba(255, 215, 0, 0.8); }
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 2px 15px rgba(255, 215, 0, 0.6);
            letter-spacing: 2px;
            animation: titleShine 3s ease-in-out infinite;
        }

        @keyframes titleShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .game-area {
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px 15px 15px;
            position: relative;
        }

        .game-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 70%, rgba(255, 215, 0, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 70% 30%, rgba(59, 130, 246, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        #game-canvas {
            border: 3px solid #ffd700;
            border-radius: 15px;
            background: linear-gradient(145deg, #1e40af, #1e3a8a);
            box-shadow: 
                0 0 60px rgba(255, 215, 0, 0.5),
                0 20px 60px rgba(59, 130, 246, 0.3),
                0 0 100px rgba(16, 185, 129, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
            position: relative;
            transition: all 0.3s ease;
        }

        #game-canvas:hover {
            box-shadow: 
                0 0 80px rgba(255, 215, 0, 0.5),
                0 25px 80px rgba(0, 0, 0, 0.6),
                inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #game-canvas::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #667eea, #ffd700);
            background-size: 300% 300%;
            border-radius: 18px;
            z-index: -1;
            animation: borderGlow 4s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at center, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: overlayFade 0.5s ease-out;
        }

        @keyframes overlayFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: 
                linear-gradient(145deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 25px;
            padding: 3rem;
            text-align: center;
            min-width: 400px;
            max-width: 600px;
            backdrop-filter: blur(30px);
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(255, 215, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
            position: relative;
            animation: modalSlideIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes modalSlideIn {
            from { 
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #667eea, #ffd700);
            background-size: 300% 300%;
            border-radius: 27px;
            z-index: -1;
            animation: modalBorderGlow 4s ease-in-out infinite;
        }

        @keyframes modalBorderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 2.2rem;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 1.5rem;
            text-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
            letter-spacing: 2px;
            animation: modalTitleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes modalTitleGlow {
            from { 
                text-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 6px 25px rgba(255, 215, 0, 0.9);
                transform: scale(1.02);
            }
        }

        /* Efeito de Transi√ß√£o de N√≠vel */
        .level-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0) 0%, 
                rgba(0, 0, 0, 0.5) 50%, 
                rgba(0, 0, 0, 1) 100%);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 1.5s ease-in-out;
        }

        .level-transition.active {
            opacity: 1;
            visibility: visible;
        }

        .transition-text {
            color: #ffd700;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .modal-content {
            margin-bottom: 2.5rem;
            line-height: 1.7;
            font-size: 1.1rem;
            color: #e0e0e0;
        }

        .modal-content p {
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            border: 2px solid transparent;
            backdrop-filter: blur(20px);
        }

        .modal-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .modal-btn:hover::before {
            left: 100%;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
            border-color: rgba(255, 107, 53, 0.3);
        }

        .modal-btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            border-color: rgba(102, 126, 234, 0.3);
        }

        .modal-btn.tertiary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
        }

        .modal-btn:hover {
            transform: translateY(-3px) scale(1.05);
            filter: brightness(1.1);
        }

        .modal-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .victory-stats {
            margin: 2rem 0;
            padding: 2rem;
            background: 
                linear-gradient(145deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 107, 53, 0.1) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.8rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 215, 0, 0.4);
            transform: translateX(5px);
        }

        .stat-label {
            font-size: 1rem;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            color: #ffd700;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: statGlow 2s ease-in-out infinite alternate;
        }

        @keyframes statGlow {
            from { text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 4px 20px rgba(255, 215, 0, 0.8); }
        }

        /* Responsivo */
        @media (max-width: 768px) {
            .game-hud {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .hud-left, .hud-right {
                display: flex;
                gap: 0.8rem;
                justify-content: center;
                flex-wrap: wrap;
            }

            .hud-item {
                padding: 0.6rem 1rem;
                min-width: 80px;
            }

            .game-title {
                font-size: 1.4rem;
                text-align: center;
            }

            #game-canvas {
                width: 90vw;
                height: auto;
                max-width: 400px;
            }

            .menu-container {
                padding: 2rem 1rem;
                max-width: 95%;
                margin: 0 10px;
            }

            .logo-title {
                font-size: 2.5rem;
            }

            .logo-icon {
                font-size: 4rem;
            }

            .menu-btn {
                padding: 1rem 1.5rem;
                font-size: 1rem;
                min-height: 60px;
            }

            .modal {
                min-width: 320px;
                max-width: 90%;
                padding: 2rem 1.5rem;
                margin: 0 20px;
            }

            .modal-title {
                font-size: 1.8rem;
            }

            .modal-actions {
                flex-direction: column;
                gap: 1rem;
            }

            .modal-btn {
                width: 100%;
                padding: 1rem;
            }

            .loading-bar-container {
                width: 280px;
            }

            .game-area {
                padding: 15px 8px 8px;
            }

            .stat-item {
                padding: 0.6rem 1rem;
                margin: 0.8rem 0;
            }
        }

        @media (max-width: 480px) {
            .menu-container {
                padding: 1.5rem 0.8rem;
            }

            .logo-title {
                font-size: 2rem;
            }

            .logo-subtitle {
                font-size: 1.1rem;
            }

            .hud-left, .hud-right {
                gap: 0.5rem;
            }

            .hud-item {
                padding: 0.5rem 0.8rem;
                min-width: 70px;
            }

            .hud-label {
                font-size: 0.7rem;
            }

            .hud-value {
                font-size: 1rem;
            }

            .modal {
                padding: 1.5rem 1rem;
            }

            .modal-title {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Tela de Loading -->
    <div id="loading-screen" class="screen active">
        <div class="loading-container">
            <div class="logo-loading">
                <div class="logo-icon">üèõÔ∏è</div>
                <h1 class="logo-text">Labirinto de Creta</h1>
            </div>
            <div class="loading-bar-container">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <div class="loading-text" id="loading-text">Inicializando...</div>
            <div class="loading-info">
                <p>üéÆ Preparando o desafio do Minotauro...</p>
            </div>
        </div>
    </div>

    <!-- Tela de Menu -->
    <div id="menu-screen" class="screen">
        <div class="menu-container">
            <div class="menu-header">
                <div class="logo">
                    <div class="logo-icon">üèõÔ∏è</div>
                    <h1 class="logo-title">Labirinto de Creta</h1>
                    <p class="logo-subtitle">O Desafio do Minotauro</p>
                </div>
            </div>
            <div class="menu-buttons">
                <button id="btn-start-game" class="menu-btn primary">
                    <span>‚öîÔ∏è</span>
                    <span>Iniciar Jogo</span>
                </button>
                <button id="btn-help" class="menu-btn secondary">
                    <span>‚ùì</span>
                    <span>Como Jogar</span>
                </button>
                <button id="btn-settings" class="menu-btn tertiary">
                    <span>‚öôÔ∏è</span>
                    <span>Configura√ß√µes</span>
                </button>
            </div>
            <div class="menu-footer">
                <p class="controls-hint">üéÆ WASD para mover ‚Ä¢ SPACE para Fio ‚Ä¢ SHIFT para correr</p>
                <p class="version-info">v2.1.0 ‚Ä¢ HTML5 Game</p>
            </div>
        </div>
    </div>

    <!-- Tela de Jogo -->
    <div id="game-screen" class="screen">
        <div class="game-hud">
            <div class="hud-left">
                <div class="hud-item">
                    <span class="hud-label">N√≠vel:</span>
                    <span class="hud-value" id="hud-level">1</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">Tempo:</span>
                    <span class="hud-value" id="hud-time">0s</span>
                </div>
            </div>
            <div class="hud-center">
                <h1 class="game-title">üèõÔ∏è Labirinto de Creta</h1>
            </div>
            <div class="hud-right">
                <div class="hud-item">
                    <span class="hud-label">Fio:</span>
                    <span class="hud-value" id="hud-thread">INATIVO</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">Minotauro:</span>
                    <span class="hud-value" id="hud-minotaur">PATRULHA</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">Corrida:</span>
                    <span class="hud-value" id="hud-running">üö∂</span>
                </div>
            </div>
        </div>
        <div class="game-area">
            <canvas id="game-canvas" width="600" height="450"></canvas>
        </div>
    </div>

    <!-- Overlay de Game Over -->
    <div id="gameover-overlay" class="overlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üíÄ Capturado!</h2>
            </div>
            <div class="modal-content">
                <p>O Minotauro te capturou! Tente novamente.</p>
            </div>
            <div class="modal-actions">
                <button id="btn-retry" class="modal-btn primary">üîÑ Tentar Novamente</button>
                <button id="btn-menu-from-gameover" class="modal-btn secondary">üè† Menu</button>
            </div>
        </div>
    </div>

    <!-- Overlay de Vit√≥ria -->
    <div id="victory-overlay" class="overlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üéâ N√≠vel Conclu√≠do!</h2>
            </div>
            <div class="modal-content">
                <p>Parab√©ns! Voc√™ escapou do labirinto!</p>
                <div class="victory-stats">
                    <div class="stat-item">
                        <span class="stat-label">Tempo:</span>
                        <span class="stat-value" id="victory-time">0s</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">N√≠vel:</span>
                        <span class="stat-value" id="victory-level">1</span>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button id="btn-next-level" class="modal-btn primary">‚û°Ô∏è Pr√≥ximo N√≠vel</button>
                <button id="btn-menu-from-victory" class="modal-btn secondary">üè† Menu</button>
            </div>
        </div>
    </div>

    <!-- Overlay de Transi√ß√£o de N√≠vel -->
    <div id="level-transition" class="level-transition">
        <div class="transition-text" id="transition-text">
            üèõÔ∏è Entrando no Pr√≥ximo N√≠vel...
        </div>
    </div>

    <script>
        // JOGO LABIRINTO DE CRETA - VERS√ÉO SIMPLIFICADA
        class LabirintoDeCreta {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameState = 'menu';
                this.level = 1;
                this.startTime = 0;
                this.gameTime = 0;
                this.maze = null;
                this.player = { x: 1.5, y: 1.5, r: 0.3, trail: [] };
                this.minotaur = { x: 1.5, y: 1.5, state: 'PATROL', vx: 0, vy: 0, lastDir: 0 };
                this.keys = new Set();
                this.threadActive = false;
                this.isRunning = false; // Estado de corrida
                this.isTransitioning = false; // Estado de transi√ß√£o entre n√≠veis
                this.cellSize = 30;
                
                // üéµ SISTEMA DE √ÅUDIO COMPLETO
                this.audioContext = null;
                this.sounds = {};
                this.musicVolume = 0.3;
                this.sfxVolume = 0.5;
                this.currentMusic = null;
                this.audioInitialized = false;
                this.lastTime = 0;
                this.gameLoop = null;
            }

            init() {
                this.setupEventListeners();
                this.initAudio();
                this.showLoadingProgress();
            }

            // üéµ SISTEMA DE √ÅUDIO COMPLETO
            async initAudio() {
                console.log('üéµ Inicializando sistema de √°udio...');
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Criar todas as trilhas e efeitos sonoros
                    await this.createSounds();
                    
                    this.audioInitialized = true;
                    console.log('‚úÖ Sistema de √°udio inicializado!');
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è √Åudio n√£o dispon√≠vel:', error);
                }
            }

            async createSounds() {
                // üéµ TRILHAS SONORAS PROCEDURAIS
                this.sounds = {
                    // M√∫sicas de fundo
                    menuMusic: this.createAmbientMusic(220, 'menu'), // L√° menor - misterioso
                    gameMusic: this.createAmbientMusic(174, 'game'), // F√° menor - tens√£o
                    chaseMusic: this.createAmbientMusic(196, 'chase'), // Sol menor - persegui√ß√£o
                    victoryMusic: this.createAmbientMusic(261, 'victory'), // D√≥ maior - vit√≥ria
                    
                    // Efeitos sonoros
                    footstep: this.createFootstepSound(),
                    runFootstep: this.createRunFootstepSound(),
                    minotaurRoar: this.createMinotaurRoar(),
                    threadActivate: this.createThreadSound(),
                    portalEnter: this.createPortalSound(),
                    levelComplete: this.createLevelCompleteSound(),
                    gameOver: this.createGameOverSound(),
                    buttonClick: this.createButtonClickSound(),
                    minotaurAttack: this.createMinotaurAttackSound(),
                    heartbeat: this.createHeartbeatSound()
                };
                
                console.log('üéµ Todas as trilhas e efeitos criados!');
            }

            createAmbientMusic(baseFreq, type) {
                if (!this.audioContext) return null;
                
                const music = {
                    oscillators: [],
                    gainNodes: [],
                    isPlaying: false,
                    type: type
                };
                
                // Criar m√∫sica ambiente baseada no tipo
                const chords = this.getMusicChords(type);
                
                chords.forEach((freq, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
                    oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    music.oscillators.push(oscillator);
                    music.gainNodes.push(gainNode);
                });
                
                return music;
            }

            getMusicChords(type) {
                switch(type) {
                    case 'menu':
                        return [220, 261, 329, 392]; // L√° menor - ambiente misterioso
                    case 'game':
                        return [174, 207, 261, 311]; // F√° menor - tens√£o constante
                    case 'chase':
                        return [196, 233, 294, 349]; // Sol menor - persegui√ß√£o intensa
                    case 'victory':
                        return [261, 329, 392, 523]; // D√≥ maior - vit√≥ria gloriosa
                    default:
                        return [220, 261, 329, 392];
                }
            }

            createFootstepSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(80, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.1);
                    
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.2, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                    
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }

            createRunFootstepSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(120, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(60, this.audioContext.currentTime + 0.05);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.05);
                };
            }

            createMinotaurRoar() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator1 = this.audioContext.createOscillator();
                    const oscillator2 = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator1.type = 'sawtooth';
                    oscillator1.frequency.setValueAtTime(50, this.audioContext.currentTime);
                    oscillator1.frequency.exponentialRampToValueAtTime(30, this.audioContext.currentTime + 0.5);
                    
                    oscillator2.type = 'square';
                    oscillator2.frequency.setValueAtTime(75, this.audioContext.currentTime);
                    oscillator2.frequency.exponentialRampToValueAtTime(45, this.audioContext.currentTime + 0.5);
                    
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.6, this.audioContext.currentTime + 0.1);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.4, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
                    
                    oscillator1.connect(filterNode);
                    oscillator2.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator1.start(this.audioContext.currentTime);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + 0.5);
                    oscillator2.stop(this.audioContext.currentTime + 0.5);
                };
            }

            createThreadSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }

            createPortalSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(200 + i * 100, this.audioContext.currentTime);
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.2, this.audioContext.currentTime + 0.1);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, i * 50);
                    }
                };
            }

            createLevelCompleteSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const frequencies = [261, 329, 392, 523]; // Acorde de D√≥ maior
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'triangle';
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.4, this.audioContext.currentTime + 0.1);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 1);
                        }, index * 100);
                    });
                };
            }

            createGameOverSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const frequencies = [220, 207, 196, 174]; // Descida triste
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'sawtooth';
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.3, this.audioContext.currentTime + 0.2);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.8);
                        }, index * 200);
                    });
                };
            }

            createButtonClickSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.2, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }

            createMinotaurAttackSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                    
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(500, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.7, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                    
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                };
            }

            createHeartbeatSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    // Batida dupla do cora√ß√£o
                    for (let i = 0; i < 2; i++) {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.sfxVolume * 0.4, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.2);
                        }, i * 150);
                    }
                };
            }

            // üéµ CONTROLE DE M√öSICA
            playMusic(musicName) {
                if (!this.audioInitialized || !this.sounds[musicName]) return;
                
                // Parar m√∫sica atual
                this.stopCurrentMusic();
                
                const music = this.sounds[musicName];
                
                try {
                    music.oscillators.forEach((osc, index) => {
                        osc.start(this.audioContext.currentTime);
                        
                        // Fade in gradual
                        const gain = music.gainNodes[index];
                        gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(this.musicVolume * 0.1, this.audioContext.currentTime + 2);
                        
                        // Varia√ß√µes sutis na frequ√™ncia
                        setInterval(() => {
                            if (music.isPlaying) {
                                const variation = 0.98 + Math.random() * 0.04; // ¬±2% de varia√ß√£o
                                osc.frequency.setValueAtTime(
                                    osc.frequency.value * variation, 
                                    this.audioContext.currentTime
                                );
                            }
                        }, 2000 + Math.random() * 2000);
                    });
                    
                    music.isPlaying = true;
                    this.currentMusic = music;
                    
                    console.log(`üéµ Tocando m√∫sica: ${musicName}`);
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erro ao tocar m√∫sica:', error);
                }
            }

            stopCurrentMusic() {
                if (this.currentMusic && this.currentMusic.isPlaying) {
                    try {
                        this.currentMusic.gainNodes.forEach(gain => {
                            gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1);
                        });
                        
                        setTimeout(() => {
                            if (this.currentMusic) {
                                this.currentMusic.oscillators.forEach(osc => {
                                    try { osc.stop(); } catch(e) {}
                                });
                                this.currentMusic.isPlaying = false;
                            }
                        }, 1000);
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erro ao parar m√∫sica:', error);
                    }
                }
            }

            // üîä TOCAR EFEITOS SONOROS
            playSound(soundName) {
                if (!this.audioInitialized || !this.sounds[soundName]) return;
                
                try {
                    this.sounds[soundName]();
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Erro ao tocar som ${soundName}:`, error);
                }
            }

            showLoadingProgress() {
                let progress = 0;
                const messages = [
                    'Carregando recursos...',
                    'Configurando labirinto...',
                    'Preparando Minotauro...',
                    'Inicializando √°udio... üéµ',
                    'Pronto para a aventura!'
                ];

                const interval = setInterval(() => {
                    progress += 20;
                    document.getElementById('loading-progress').style.width = `${progress}%`;
                    document.getElementById('loading-text').textContent = messages[Math.floor(progress / 20) - 1] || messages[0];

                    // üéµ Testar √°udio na √∫ltima etapa
                    if (progress === 80 && this.audioInitialized) {
                        this.playSound('buttonClick');
                        console.log('üéµ √Åudio testado com sucesso!');
                    }

                    if (progress >= 100) {
                        clearInterval(interval);
                        setTimeout(() => {
                            this.showScreen('menu');
                            this.playMusic('menuMusic'); // üéµ M√∫sica do menu
                        }, 1000);
                    }
                }, 500);
            }

            showScreen(screenName) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(`${screenName}-screen`).classList.add('active');
                
                // Controlar visibilidade do HUD
                const hud = document.querySelector('.game-hud');
                if (screenName === 'game') {
                    // HUD fica oculto durante o jogo
                    hud.classList.remove('show');
                    if (!this.canvas) {
                        this.initGame();
                    }
                } else {
                    // HUD fica oculto em outras telas tamb√©m
                    hud.classList.remove('show');
                }
            }

            showOverlay(overlayName) {
                document.getElementById(`${overlayName}-overlay`).style.display = 'flex';
            }

            toggleHUD(show = false) {
                const hud = document.querySelector('.game-hud');
                if (show) {
                    hud.classList.add('show');
                } else {
                    hud.classList.remove('show');
                }
            }

            hideOverlay(overlayName) {
                document.getElementById(`${overlayName}-overlay`).style.display = 'none';
            }

            setupEventListeners() {
                // Menu buttons
                document.getElementById('btn-start-game').addEventListener('click', () => {
                    this.startNewGame();
                });

                document.getElementById('btn-help').addEventListener('click', () => {
                    this.showHelp();
                });

                document.getElementById('btn-settings').addEventListener('click', () => {
                    this.playSound('buttonClick'); // üîä Som de clique
                    this.showSettings();
                });

                // Game over buttons
                document.getElementById('btn-retry').addEventListener('click', () => {
                    this.playSound('buttonClick'); // üîä Som de clique
                    this.hideOverlay('gameover');
                    this.restartLevel();
                });

                document.getElementById('btn-menu-from-gameover').addEventListener('click', () => {
                    this.playSound('buttonClick'); // üîä Som de clique
                    this.hideOverlay('gameover');
                    this.showScreen('menu');
                    this.playMusic('menuMusic'); // üéµ M√∫sica do menu
                    this.stopGame();
                });

                // Victory buttons
                document.getElementById('btn-next-level').addEventListener('click', () => {
                    this.playSound('buttonClick'); // üîä Som de clique
                    this.hideOverlay('victory');
                    this.startLevelTransition();
                });

                document.getElementById('btn-menu-from-victory').addEventListener('click', () => {
                    this.playSound('buttonClick'); // üîä Som de clique
                    this.hideOverlay('victory');
                    this.showScreen('menu');
                    this.playMusic('menuMusic'); // üéµ M√∫sica do menu
                    this.stopGame();
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys.add(e.code);
                    if (e.code === 'Escape' && this.gameState === 'playing') {
                        this.showScreen('menu');
                        this.stopGame();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys.delete(e.code);
                });
            }

            initGame() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Canvas inicial pequeno - vai crescer com os n√≠veis
                this.canvas.width = 600;
                this.canvas.height = 450;
                this.canvas.style.width = '600px';
                this.canvas.style.height = '450px';
                
                console.log('üéÆ Canvas inicializado: 600x450px (cresce com n√≠veis)');
                
                // Ajustar canvas para responsividade apenas
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // For√ßar HUD aparecer
                const hud = document.querySelector('.game-hud');
                if (hud) {
                    hud.style.display = 'flex';
                    console.log('üó∫Ô∏è HUD inicializado!');
                }
            }

            resizeCanvas() {
                // üó∫Ô∏è RESIZE B√ÅSICO - O TAMANHO DIN√ÇMICO √â CONTROLADO PELO N√çVEL
                const container = this.canvas.parentElement;
                
                // Apenas garantir que n√£o ultrapasse o container
                const maxWidth = container.clientWidth - 20;
                const maxHeight = container.clientHeight - 80; // Espa√ßo para HUD
                
                // Se o canvas atual for maior que o container, redimensionar proporcionalmente
                if (this.canvas.width > maxWidth || this.canvas.height > maxHeight) {
                    const scaleX = maxWidth / this.canvas.width;
                    const scaleY = maxHeight / this.canvas.height;
                    const scale = Math.min(scaleX, scaleY, 1); // N√£o aumentar, apenas diminuir
                    
                    this.canvas.style.width = `${this.canvas.width * scale}px`;
                    this.canvas.style.height = `${this.canvas.height * scale}px`;
                    
                    console.log(`üó∫Ô∏è Canvas redimensionado para caber: Scale ${scale.toFixed(2)}x`);
                }
                
                // N√£o regenerar labirinto no resize - apenas no generateMaze()
            }

            startNewGame() {
                this.playSound('buttonClick'); // üîä Som de clique
                this.level = 1;
                this.showScreen('game');
                this.playMusic('gameMusic'); // üéµ M√∫sica de jogo
                this.startLevel();
            }

            startLevel() {
                console.log(`üéÆüè∞ INICIANDO N√çVEL ${this.level} - PREPARA-SE PARA O MINOTAURO!`);
                
                this.generateMaze();
                this.resetPlayer();
                
                // üêÇ GARANTIR QUE O BOSS SEMPRE APARE√áA
                console.log('üî• Invocando o Minotauro...');
                this.resetMinotaur();
                
                // Verifica√ß√£o de seguran√ßa
                if (!this.minotaur.x || !this.minotaur.y) {
                    console.error('‚ö†Ô∏è ERRO: Minotauro n√£o foi posicionado! Corrigindo...');
                    this.minotaur.x = Math.max(2.5, this.maze.width - 3);
                    this.minotaur.y = Math.max(2.5, this.maze.height - 3);
                    this.minotaur.state = 'HUNT';
                }
                
                this.startTime = Date.now();
                this.gameTime = 0;
                this.gameState = 'playing';
                
                if (this.gameLoop) {
                    cancelAnimationFrame(this.gameLoop);
                }
                this.gameLoop = requestAnimationFrame((time) => this.update(time));
                
                // üó∫Ô∏è GARANTIR QUE O HUD APARE√áA
                const hud = document.querySelector('.game-hud');
                if (hud) {
                    hud.classList.add('show');
                    hud.style.display = 'flex';
                    console.log('üó∫Ô∏è HUD ativado!');
                }
                
                console.log(`‚úÖ N√≠vel ${this.level} iniciado com BOSS ativo em (${this.minotaur.x.toFixed(1)}, ${this.minotaur.y.toFixed(1)})!`);
                console.log(`üèπ Teseu vs Minotauro - QUE COMECE A CA√áADA!`);
                console.log(`üî• Canvas din√¢mico: ${this.canvas.width}x${this.canvas.height}px - CellSize: ${this.cellSize.toFixed(1)}px`);
            }

            generateMaze() {
                // üèõÔ∏è CANVAS DIN√ÇMICO BASEADO NO N√çVEL! üòÇ
                
                // Tamanho da c√©lula diminui conforme avan√ßa nos n√≠veis (mais dif√≠cil)
                const baseCellSize = 20; // Come√ßa com c√©lulas grandes
                const cellSizeReduction = Math.min(8, this.level * 0.5); // Reduz gradualmente
                const targetCellSize = Math.max(8, baseCellSize - cellSizeReduction);
                
                console.log(`üéÆ N√≠vel ${this.level}: CellSize = ${targetCellSize}px (Base: ${baseCellSize}, Redu√ß√£o: ${cellSizeReduction})`);
                
                // Tamanho do canvas cresce com o n√≠vel
                const levelMultiplier = 1 + (this.level - 1) * 0.1; // Cresce 10% por n√≠vel
                const baseCanvasWidth = 600;
                const baseCanvasHeight = 450;
                
                const canvasWidth = Math.min(1000, baseCanvasWidth * levelMultiplier); // M√°x 1000px
                const canvasHeight = Math.min(750, baseCanvasHeight * levelMultiplier); // M√°x 750px
                
                // Atualizar tamanho do canvas
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                this.canvas.style.width = `${canvasWidth}px`;
                this.canvas.style.height = `${canvasHeight}px`;
                
                console.log(`üó∫Ô∏è Canvas Nivel ${this.level}: ${canvasWidth}x${canvasHeight}px (Mult: ${levelMultiplier.toFixed(1)}x)`);
                
                // Calcular dimens√µes do labirinto
                const width = Math.floor(canvasWidth / targetCellSize);
                const height = Math.floor(canvasHeight / targetCellSize);
                
                // Garantir que seja √≠mpar para algoritmo de labirinto
                const mazeWidth = width % 2 === 0 ? width - 1 : width;
                const mazeHeight = height % 2 === 0 ? height - 1 : height;
                
                console.log(`üèõÔ∏è Gerando labirinto: ${mazeWidth}x${mazeHeight} (Canvas: ${canvasWidth}x${canvasHeight})`);
                
                this.maze = {
                    width: mazeWidth,
                    height: mazeHeight,
                    walls: []
                };

                // Initialize maze with walls
                for (let y = 0; y < mazeHeight; y++) {
                    this.maze.walls[y] = [];
                    for (let x = 0; x < mazeWidth; x++) {
                        this.maze.walls[y][x] = 1;
                    }
                }

                // Create paths using recursive backtracking
                this.carveMaze(1, 1);
                
                // Garantir que in√≠cio e fim estejam livres
                this.maze.walls[1][1] = 0;
                this.maze.walls[mazeHeight - 2][mazeWidth - 2] = 0;
                
                // Criar mais caminhos para o Minotauro se mover
                this.createAdditionalPaths();
                
                // Calcular tamanho da c√©lula para renderiza√ß√£o
                this.cellSize = Math.min(canvasWidth / mazeWidth, canvasHeight / mazeHeight);
                
                console.log(`‚úÖ Labirinto gerado! CellSize: ${this.cellSize.toFixed(1)}px`);
            }

            createAdditionalPaths() {
                // Criar caminhos adicionais para melhor movimenta√ß√£o do Minotauro
                const pathsToCreate = Math.floor(this.maze.width * this.maze.height * 0.05); // 5% de caminhos extras
                
                for (let i = 0; i < pathsToCreate; i++) {
                    const x = 1 + Math.floor(Math.random() * (this.maze.width - 2));
                    const y = 1 + Math.floor(Math.random() * (this.maze.height - 2));
                    
                    // Criar pequenos caminhos extras
                    if (this.maze.walls[y] && this.maze.walls[y][x]) {
                        this.maze.walls[y][x] = 0;
                        
                        // Conectar com caminhos vizinhos se poss√≠vel
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx > 0 && nx < this.maze.width - 1 && ny > 0 && ny < this.maze.height - 1) {
                                if (Math.random() < 0.3 && this.maze.walls[ny] && this.maze.walls[ny][nx]) {
                                    this.maze.walls[ny][nx] = 0;
                                }
                            }
                        }
                    }
                }
            }

            carveMaze(x, y) {
                const dirs = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                dirs.sort(() => Math.random() - 0.5);

                this.maze.walls[y][x] = 0;

                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx > 0 && nx < this.maze.width - 1 && 
                        ny > 0 && ny < this.maze.height - 1 && 
                        this.maze.walls[ny][nx] === 1) {
                        
                        this.maze.walls[y + dy / 2][x + dx / 2] = 0;
                        this.carveMaze(nx, ny);
                    }
                }
            }

            resetPlayer() {
                this.player.x = 1.5;
                this.player.y = 1.5;
                this.player.trail = [];
            }

            resetMinotaur() {
                console.log('üêÇ INVOCANDO O BOSS CHEFE√ÉO LEND√ÅRIO - MINOTAURO!');
                
                // üí™ GARANTIR QUE O MINOTAURO SEMPRE APARE√áA - ELE √â O BOSS!
                let found = false;
                let attempts = 0;
                
                // Posi√ß√µes estrat√©gicas para o boss chefe√£o
                const bossPositions = [
                    // Cantos do labirinto - posi√ß√µes de poder
                    { x: this.maze.width - 2.5, y: this.maze.height - 2.5, name: 'Canto do Poder' },
                    { x: this.maze.width - 3.5, y: this.maze.height - 2.5, name: 'Guardi√£o da Sa√≠da' },
                    { x: this.maze.width - 2.5, y: this.maze.height - 3.5, name: 'Protetor do Portal' },
                    
                    // Centro do labirinto - dom√≠nio absoluto
                    { x: this.maze.width / 2, y: this.maze.height / 2, name: 'Senhor do Centro' },
                    { x: (this.maze.width / 2) + 1, y: this.maze.height / 2, name: 'Dominador Central' },
                    { x: this.maze.width / 2, y: (this.maze.height / 2) + 1, name: 'Mestre Central' },
                    
                    // Posi√ß√µes intermedi√°rias - ca√ßador
                    { x: this.maze.width * 0.75, y: this.maze.height * 0.75, name: 'Ca√ßador das Sombras' },
                    { x: this.maze.width * 0.25, y: this.maze.height * 0.75, name: 'Perseguidor Implacavel' },
                    { x: this.maze.width * 0.75, y: this.maze.height * 0.25, name: 'Vigia dos Corredores' },
                    
                    // Posi√ß√µes de emerg√™ncia
                    { x: 3.5, y: 3.5, name: 'Predador Inicial' },
                    { x: 4.5, y: 4.5, name: 'Bestia Despertada' },
                    { x: 2.5, y: 3.5, name: 'Terror Primitivo' }
                ];
                
                // Testar cada posi√ß√£o do boss
                for (const pos of bossPositions) {
                    attempts++;
                    if (!this.isWall(pos.x, pos.y) && 
                        pos.x > 0 && pos.x < this.maze.width && 
                        pos.y > 0 && pos.y < this.maze.height) {
                        this.minotaur.x = pos.x;
                        this.minotaur.y = pos.y;
                        console.log(`üí™ BOSS POSICIONADO: ${pos.name} em (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
                        found = true;
                        break;
                    }
                }
                
                // SISTEMA DE EMERG√äNCIA - O BOSS SEMPRE DEVE APARECER!
                if (!found) {
                    console.warn('‚ö†Ô∏è ATIVA√á√ÉO DE EMERG√äNCIA - FOR√áANDO SPAWN DO BOSS!');
                    
                    // Varredura completa garantindo que o boss apare√ßa
                    outerLoop: for (let y = 2; y < this.maze.height - 1; y += 2) {
                        for (let x = 2; x < this.maze.width - 1; x += 2) {
                            attempts++;
                            const testX = x + 0.5;
                            const testY = y + 0.5;
                            
                            if (!this.isWall(testX, testY)) {
                                this.minotaur.x = testX;
                                this.minotaur.y = testY;
                                console.log(`üéÜ BOSS EMERGENCIAL SPAWNED em (${testX.toFixed(1)}, ${testY.toFixed(1)})`);
                                found = true;
                                break outerLoop;
                            }
                            
                            // Limite de seguran√ßa
                            if (attempts > 100) {
                                // √öLTIMO RECURSO - For√ßar posi√ß√£o
                                this.minotaur.x = Math.max(2.5, Math.min(this.maze.width - 2.5, this.maze.width / 2));
                                this.minotaur.y = Math.max(2.5, Math.min(this.maze.height - 2.5, this.maze.height / 2));
                                console.warn(`üî• FOR√áANDO POSI√á√ÉO DO BOSS: (${this.minotaur.x.toFixed(1)}, ${this.minotaur.y.toFixed(1)})`);
                                found = true;
                                break outerLoop;
                            }
                        }
                    }
                }
                
                // Configurar o boss como uma amea√ßa lend√°ria
                this.minotaur.state = 'HUNT'; // Novo estado mais agressivo
                this.minotaur.vx = 0;
                this.minotaur.vy = 0;
                this.minotaur.lastDir = 0;
                this.minotaur.aggressionLevel = 1.0; // N√≠vel m√°ximo de agress√£o
                this.minotaur.huntTimer = 0;
                this.minotaur.lastPlayerPos = { x: this.player.x, y: this.player.y };
                
                // Logs do boss lend√°rio
                console.log(`üêÇüí™ MINOTAURO - O BOSS CHEFE√ÉO DESPERTA!`);
                console.log(`üè∞ Posi√ß√£o Final: (${this.minotaur.x.toFixed(1)}, ${this.minotaur.y.toFixed(1)})`);
                console.log(`üèõÔ∏è Arena: ${this.maze.width}x${this.maze.height}`);
                console.log(`‚úÖ Boss Status: ${found ? 'ATIVO E PERIGOSO' : 'ERROR - REPORTE ESTE BUG!'}`);
                console.log(`üéØ Tentativas de Spawn: ${attempts}`);
                console.log(`üî• N√≠vel de Agress√£o: ${this.minotaur.aggressionLevel}`);
                
                if (!found) {
                    console.error('‚ùå‚ùå‚ùå ERRO CR√çTICO: BOSS N√ÉO P√îDE SER SPAWNADO!');
                }
            }

            update(currentTime) {
                if (this.gameState !== 'playing' && this.gameState !== 'transitioning') return;
                if (this.isTransitioning && this.gameState === 'transitioning') return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.gameTime = Date.now() - this.startTime;
                
                // Debug - verificar posi√ß√£o do minotauro (remover depois)
                if (Math.random() < 0.01) { // Log apenas 1% das vezes para n√£o spam
                    console.log(`üêÇ Minotauro: x=${this.minotaur.x.toFixed(2)}, y=${this.minotaur.y.toFixed(2)}, state=${this.minotaur.state}`);
                }

                this.updatePlayer(deltaTime);
                this.updateMinotaur(deltaTime);
                this.checkCollisions();
                this.updateHUD();
                this.render();

                this.gameLoop = requestAnimationFrame((time) => this.update(time));
            }

            updatePlayer(deltaTime) {
                // Verifica se est√° correndo (Shift pressionado)
                const wasRunning = this.isRunning;
                this.isRunning = this.keys.has('ShiftLeft') || this.keys.has('ShiftRight');
                
                // Velocidade base e multiplicador de corrida
                const baseSpeed = 0.003;
                const runMultiplier = 2.0; // Corre 2x mais r√°pido
                const speed = this.isRunning ? baseSpeed * runMultiplier : baseSpeed;
                
                let dx = 0, dy = 0;
                const wasMoving = dx !== 0 || dy !== 0;

                if (this.keys.has('KeyW') || this.keys.has('ArrowUp')) dy -= speed * deltaTime;
                if (this.keys.has('KeyS') || this.keys.has('ArrowDown')) dy += speed * deltaTime;
                if (this.keys.has('KeyA') || this.keys.has('ArrowLeft')) dx -= speed * deltaTime;
                if (this.keys.has('KeyD') || this.keys.has('ArrowRight')) dx += speed * deltaTime;

                const wasThreadActive = this.threadActive;
                this.threadActive = this.keys.has('Space');
                
                // üîä SOM DO FIO DE ARIADNE
                if (this.threadActive && !wasThreadActive) {
                    this.playSound('threadActivate');
                }

                // Move player with collision
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;
                
                let actuallyMoved = false;

                if (!this.isWall(newX, this.player.y)) {
                    this.player.x = newX;
                    actuallyMoved = true;
                }
                if (!this.isWall(this.player.x, newY)) {
                    this.player.y = newY;
                    actuallyMoved = true;
                }
                
                // üîä SONS DE MOVIMENTO
                if (actuallyMoved && Math.random() < 0.1) { // 10% chance por frame
                    if (this.isRunning) {
                        this.playSound('runFootstep');
                    } else {
                        this.playSound('footstep');
                    }
                }

                // Add to trail
                if (this.threadActive && this.player.trail.length % 5 === 0) {
                    this.player.trail.push({
                        x: this.player.x,
                        y: this.player.y
                    });
                    if (this.player.trail.length > 100) {
                        this.player.trail.shift();
                    }
                }
            }

            updateMinotaur(deltaTime) {
                // üêÇüí™ AI DO BOSS CHEFE√ÉO - MINOTAURO LEND√ÅRIO
                const baseSpeed = 0.002;
                const bossSpeed = baseSpeed * (1 + this.level * 0.1); // Fica mais r√°pido a cada n√≠vel
                
                // Calcular dist√¢ncia para Teseu
                const distToPlayer = Math.sqrt(
                    Math.pow(this.player.x - this.minotaur.x, 2) + 
                    Math.pow(this.player.y - this.minotaur.y, 2)
                );
                
                // Atualizar √∫ltima posi√ß√£o conhecida do jogador
                if (distToPlayer < 6 || this.hasLineOfSight()) {
                    this.minotaur.lastPlayerPos = { x: this.player.x, y: this.player.y };
                    this.minotaur.huntTimer = 5000; // Lembrar por 5 segundos
                }
                
                // Reduzir timer de ca√ßa
                this.minotaur.huntTimer = Math.max(0, this.minotaur.huntTimer - deltaTime);
                
                // üéØ ESTADOS DO BOSS:
                // üîä SONS BASEADOS NO ESTADO DO MINOTAURO
                const previousState = this.minotaur.state;
                
                if (distToPlayer < 2) {
                    // MODO ATAQUE - Muito pr√≥ximo!
                    this.minotaur.state = 'ATTACK';
                    const dx = this.player.x - this.minotaur.x;
                    const dy = this.player.y - this.minotaur.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    // üîä Som de ataque se mudou para ATTACK
                    if (previousState !== 'ATTACK' && Math.random() < 0.3) {
                        this.playSound('minotaurAttack');
                    }
                    
                    // Ataque direcionado muito r√°pido
                    this.minotaur.vx = (dx / dist) * bossSpeed * deltaTime * 3.0;
                    this.minotaur.vy = (dy / dist) * bossSpeed * deltaTime * 3.0;
                    
                } else if (distToPlayer < 5 && this.hasLineOfSight()) {
                    // MODO CA√áA - Pode ver o jogador
                    this.minotaur.state = 'CHASE';
                    const dx = this.player.x - this.minotaur.x;
                    const dy = this.player.y - this.minotaur.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    // üîä Som de rugido se mudou para CHASE
                    if (previousState !== 'CHASE' && Math.random() < 0.2) {
                        this.playSound('minotaurRoar');
                        this.playMusic('chaseMusic'); // M√∫sica mais intensa
                    }
                    
                    // Ca√ßa r√°pida e direcionada
                    this.minotaur.vx = (dx / dist) * bossSpeed * deltaTime * 2.0;
                    this.minotaur.vy = (dy / dist) * bossSpeed * deltaTime * 2.0;
                    
                    // üîä Batimentos card√≠acos quando perseguido
                    if (Math.random() < 0.05) { // 5% chance por frame
                        this.playSound('heartbeat');
                    }
                    
                } else if (this.minotaur.huntTimer > 0) {
                    // MODO PERSEGUI√á√ÉO - Vai para √∫ltima posi√ß√£o conhecida
                    this.minotaur.state = 'HUNT';
                    const dx = this.minotaur.lastPlayerPos.x - this.minotaur.x;
                    const dy = this.minotaur.lastPlayerPos.y - this.minotaur.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    if (dist > 0.5) {
                        this.minotaur.vx = (dx / dist) * bossSpeed * deltaTime * 1.5;
                        this.minotaur.vy = (dy / dist) * bossSpeed * deltaTime * 1.5;
                    } else {
                        // Chegou na √∫ltima posi√ß√£o, come√ßar patrulha
                        this.minotaur.huntTimer = 0;
                    }
                    
                } else {
                    // üö∂ MODO PATRULHA INTELIGENTE - EXPLORA√á√ÉO TOTAL DO LABIRINTO
                    this.minotaur.state = 'PATROL';
                    
                    // üîä Voltar m√∫sica normal se saiu da persegui√ß√£o
                    if (previousState === 'CHASE' || previousState === 'ATTACK') {
                        this.playMusic('gameMusic');
                    }
                    
                    this.minotaur.lastDir -= deltaTime;
                    
                    if (this.minotaur.lastDir <= 0) {
                        // üß† MOVIMENTO INTELIGENTE: Explorar todo o labirinto
                        let targetX, targetY;
                        
                        if (Math.random() < 0.4) {
                            // 40% - Patrulhar pontos estrat√©gicos
                            const strategicPoints = [
                                { x: this.maze.width - 2, y: this.maze.height - 2 }, // Sa√≠da
                                { x: this.maze.width / 2, y: this.maze.height / 2 }, // Centro
                                { x: this.maze.width * 0.25, y: this.maze.height * 0.25 }, // Quadrante 1
                                { x: this.maze.width * 0.75, y: this.maze.height * 0.25 }, // Quadrante 2
                                { x: this.maze.width * 0.25, y: this.maze.height * 0.75 }, // Quadrante 3
                                { x: this.maze.width * 0.75, y: this.maze.height * 0.75 }, // Quadrante 4
                                { x: 2, y: 2 }, // Pr√≥ximo ao in√≠cio
                            ];
                            
                            const target = strategicPoints[Math.floor(Math.random() * strategicPoints.length)];
                            targetX = target.x;
                            targetY = target.y;
                            
                        } else if (Math.random() < 0.7) {
                            // 30% - Movimento aleat√≥rio em dire√ß√µes v√°lidas
                            const directions = [];
                            const checkDirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
                            
                            // Verificar dire√ß√µes v√°lidas
                            for (const [dx, dy] of checkDirs) {
                                const testX = this.minotaur.x + dx * 3;
                                const testY = this.minotaur.y + dy * 3;
                                
                                if (testX > 1 && testX < this.maze.width - 1 && 
                                    testY > 1 && testY < this.maze.height - 1 &&
                                    !this.isWall(testX, testY)) {
                                    directions.push([dx, dy]);
                                }
                            }
                            
                            if (directions.length > 0) {
                                const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                                targetX = this.minotaur.x + dx * 3;
                                targetY = this.minotaur.y + dy * 3;
                            } else {
                                // Fallback: mover para centro
                                targetX = this.maze.width / 2;
                                targetY = this.maze.height / 2;
                            }
                            
                        } else {
                            // 30% - Perseguir √°reas n√£o exploradas (simula√ß√£o)
                            const unexplored = [];
                            for (let attempts = 0; attempts < 10; attempts++) {
                                const randX = 2 + Math.random() * (this.maze.width - 4);
                                const randY = 2 + Math.random() * (this.maze.height - 4);
                                
                                if (!this.isWall(randX, randY)) {
                                    unexplored.push({ x: randX, y: randY });
                                }
                            }
                            
                            if (unexplored.length > 0) {
                                const target = unexplored[Math.floor(Math.random() * unexplored.length)];
                                targetX = target.x;
                                targetY = target.y;
                            } else {
                                targetX = this.maze.width / 2;
                                targetY = this.maze.height / 2;
                            }
                        }
                        
                        // Calcular dire√ß√£o para o alvo
                        const dx = targetX - this.minotaur.x;
                        const dy = targetY - this.minotaur.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        this.minotaur.vx = (dx / dist) * bossSpeed * deltaTime;
                        this.minotaur.vy = (dy / dist) * bossSpeed * deltaTime;
                        this.minotaur.lastDir = 1000 + Math.random() * 2000; // Varia entre 1-3s
                    }
                }
                
                // Aumentar agress√£o com o tempo (boss fica mais perigoso)
                this.minotaur.aggressionLevel = Math.min(2.0, 1.0 + (this.gameTime / 30000)); // +100% agress√£o ap√≥s 30s

                // Move minotaur with collision
                const newX = this.minotaur.x + this.minotaur.vx;
                const newY = this.minotaur.y + this.minotaur.vy;

                if (!this.isWall(newX, this.minotaur.y)) {
                    this.minotaur.x = newX;
                } else {
                    this.minotaur.vx = -this.minotaur.vx;
                }

                if (!this.isWall(this.minotaur.x, newY)) {
                    this.minotaur.y = newY;
                } else {
                    this.minotaur.vy = -this.minotaur.vy;
                }
            }

            hasLineOfSight() {
                // Simplified line of sight
                return Math.random() > 0.3; // 70% chance of seeing player when close
            }

            isWall(x, y) {
                const gx = Math.floor(x);
                const gy = Math.floor(y);
                return this.maze.walls[gy]?.[gx] === 1;
            }

            checkCollisions() {
                // N√£o verificar colis√µes se j√° est√° em transi√ß√£o
                if (this.isTransitioning) return;
                
                // Check win condition
                const exitX = this.maze.width - 2;
                const exitY = this.maze.height - 2;
                
                if (Math.abs(this.player.x - exitX - 0.5) < 0.5 && 
                    Math.abs(this.player.y - exitY - 0.5) < 0.5) {
                    this.gameWon();
                    return;
                }

                // Check minotaur collision
                const dist = Math.sqrt(
                    Math.pow(this.player.x - this.minotaur.x, 2) + 
                    Math.pow(this.player.y - this.minotaur.y, 2)
                );

                if (dist < 0.8) {
                    this.gameOver();
                }
            }

            gameWon() {
                // üîä SONS DE VIT√ìRIA
                this.playSound('portalEnter');
                this.playSound('levelComplete');
                this.playMusic('victoryMusic');
                
                // N√£o mudar gameState ainda, apenas iniciar transi√ß√£o
                this.startLevelTransition();
            }

            startLevelTransition() {
                console.log('üéÜ Iniciando transi√ß√£o de n√≠vel...');
                this.isTransitioning = true;
                this.gameState = 'transitioning'; // Novo estado para transi√ß√£o
                
                const transitionOverlay = document.getElementById('level-transition');
                const transitionText = document.getElementById('transition-text');
                
                if (!transitionOverlay) {
                    console.error('‚ùå Elemento level-transition n√£o encontrado!');
                    // Fallback: ir direto para o pr√≥ximo n√≠vel
                    this.nextLevel();
                    return;
                }
                
                // Atualizar texto da transi√ß√£o
                transitionText.innerHTML = `üèõÔ∏è N√≠vel ${this.level} Completo!<br>üåü Preparando N√≠vel ${this.level + 1}...`;
                
                // Mostrar overlay de transi√ß√£o
                transitionOverlay.classList.add('active');
                console.log('‚ú® Overlay de transi√ß√£o ativado');
                
                // Aguardar 2 segundos e ent√£o ir para o pr√≥ximo n√≠vel
                setTimeout(() => {
                    console.log('‚è≥ Timeout da transi√ß√£o - indo para pr√≥ximo n√≠vel');
                    this.nextLevel();
                }, 2000);
            }

            gameOver() {
                // üîä SONS DE GAME OVER
                this.playSound('minotaurRoar'); // Rugido de vit√≥ria do Minotauro
                this.playSound('gameOver');
                this.stopCurrentMusic();
                
                this.gameState = 'gameover';
                this.showOverlay('gameover');
            }

            nextLevel() {
                this.level++;
                this.startLevel();
                
                // Remover overlay de transi√ß√£o ap√≥s o novo n√≠vel carregar
                setTimeout(() => {
                    this.endLevelTransition();
                }, 1000);
            }

            endLevelTransition() {
                const transitionOverlay = document.getElementById('level-transition');
                transitionOverlay.classList.remove('active');
                this.isTransitioning = false;
                // Garantir que o gameState volte para playing
                if (this.gameState === 'transitioning') {
                    this.gameState = 'playing';
                }
            }

            restartLevel() {
                this.startLevel();
            }

            stopGame() {
                this.gameState = 'menu';
                if (this.gameLoop) {
                    cancelAnimationFrame(this.gameLoop);
                    this.gameLoop = null;
                }
            }

            updateHUD() {
                document.getElementById('hud-level').textContent = this.level;
                document.getElementById('hud-time').textContent = `${Math.floor(this.gameTime / 1000)}s`;
                document.getElementById('hud-thread').textContent = this.threadActive ? 'ATIVO' : 'INATIVO';
                document.getElementById('hud-running').textContent = this.isRunning ? 'üèÉ' : 'üö∂';
                
                // üêÇ STATUS DETALHADO DO BOSS CHEFE√ÉO
                const minotaurElement = document.getElementById('hud-minotaur');
                let bossStatus = '';
                
                switch(this.minotaur.state) {
                    case 'ATTACK':
                        bossStatus = 'üî• ATACANDO!';
                        break;
                    case 'CHASE':
                        bossStatus = 'üèÉ‚Äç‚ôÇÔ∏è CA√áANDO';
                        break;
                    case 'HUNT':
                        bossStatus = 'üîç PERSEGUINDO';
                        break;
                    case 'PATROL':
                        bossStatus = 'üö∂ PATRULHANDO';
                        break;
                    default:
                        bossStatus = 'üêÇ ATIVO';
                }
                
                minotaurElement.textContent = bossStatus;
                
                // Mudar cor do HUD baseado no perigo
                if (this.minotaur.state === 'ATTACK') {
                    minotaurElement.style.color = '#ef4444';
                    minotaurElement.style.fontWeight = 'bold';
                } else if (this.minotaur.state === 'CHASE') {
                    minotaurElement.style.color = '#f59e0b';
                    minotaurElement.style.fontWeight = 'bold';
                } else {
                    minotaurElement.style.color = '#10b981';
                    minotaurElement.style.fontWeight = 'normal';
                }
            }

            render() {
                if (!this.ctx || !this.maze) return;

                // üé® RENDERIZA√á√ÉO OTIMIZADA PARA TODO O ESPA√áO
                
                // Limpar canvas completo
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Fundo mais claro e colorido ocupando todo o espa√ßo
                const backgroundGradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                backgroundGradient.addColorStop(0, '#1e3a8a');
                backgroundGradient.addColorStop(0.5, '#1e40af');
                backgroundGradient.addColorStop(1, '#2563eb');
                this.ctx.fillStyle = backgroundGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Calcular offset para centralizar o labirinto
                const totalMazeWidth = this.maze.width * this.cellSize;
                const totalMazeHeight = this.maze.height * this.cellSize;
                const offsetX = (this.canvas.width - totalMazeWidth) / 2;
                const offsetY = (this.canvas.height - totalMazeHeight) / 2;

                // üèóÔ∏è DESENHAR LABIRINTO CENTRALIZADO
                for (let y = 0; y < this.maze.height; y++) {
                    for (let x = 0; x < this.maze.width; x++) {
                        const renderX = offsetX + (x * this.cellSize);
                        const renderY = offsetY + (y * this.cellSize);
                        
                        if (this.maze.walls[y][x] === 1) {
                            // Paredes com gradiente dourado mais vibrante
                            const wallGradient = this.ctx.createLinearGradient(
                                renderX, renderY,
                                renderX + this.cellSize, renderY + this.cellSize
                            );
                            wallGradient.addColorStop(0, '#d97706');
                            wallGradient.addColorStop(0.5, '#f59e0b');
                            wallGradient.addColorStop(1, '#fbbf24');
                            this.ctx.fillStyle = wallGradient;
                            this.ctx.fillRect(renderX, renderY, this.cellSize, this.cellSize);
                            
                            // Borda das paredes para defini√ß√£o
                            this.ctx.strokeStyle = '#92400e';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.strokeRect(renderX, renderY, this.cellSize, this.cellSize);
                        }
                    }
                }

                // ‚≠ê PORTAL DE SA√çDA COM OFFSET CENTRALIZADO
                const exitX = this.maze.width - 2;
                const exitY = this.maze.height - 2;
                const exitRenderX = offsetX + (exitX * this.cellSize) + this.cellSize/2;
                const exitRenderY = offsetY + (exitY * this.cellSize) + this.cellSize/2;
                
                // Glow da sa√≠da
                this.ctx.save();
                this.ctx.shadowColor = '#10b981';
                this.ctx.shadowBlur = 20;
                
                // Gradiente da sa√≠da centralizado
                const exitGradient = this.ctx.createRadialGradient(
                    exitRenderX, exitRenderY, 0,
                    exitRenderX, exitRenderY, this.cellSize/2
                );
                exitGradient.addColorStop(0, '#10b981');
                exitGradient.addColorStop(0.7, '#059669');
                exitGradient.addColorStop(1, '#047857');
                
                this.ctx.fillStyle = exitGradient;
                this.ctx.fillRect(
                    exitX * this.cellSize + 2, 
                    exitY * this.cellSize + 2, 
                    this.cellSize - 4, 
                    this.cellSize - 4
                );
                this.ctx.restore();

                // Draw trail (Fio de Ariadne) com efeito especial
                if (this.threadActive && this.player.trail.length > 1) {
                    this.ctx.save();
                    this.ctx.shadowColor = '#ffd700';
                    this.ctx.shadowBlur = 10;
                    
                    // Criar gradiente para o fio
                    const trailGradient = this.ctx.createLinearGradient(
                        this.player.trail[0].x * this.cellSize,
                        this.player.trail[0].y * this.cellSize,
                        this.player.trail[this.player.trail.length - 1].x * this.cellSize,
                        this.player.trail[this.player.trail.length - 1].y * this.cellSize
                    );
                    trailGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    trailGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.8)');
                    trailGradient.addColorStop(1, 'rgba(255, 215, 0, 1)');
                    
                    this.ctx.strokeStyle = trailGradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        this.player.trail[0].x * this.cellSize, 
                        this.player.trail[0].y * this.cellSize
                    );
                    for (let i = 1; i < this.player.trail.length; i++) {
                        this.ctx.lineTo(
                            this.player.trail[i].x * this.cellSize, 
                            this.player.trail[i].y * this.cellSize
                        );
                    }
                    this.ctx.stroke();
                    this.ctx.restore();
                }

                // Draw player (Teseu) - Her√≥i sem efeitos de fuma√ßa
                this.ctx.save();
                
                const playerX = this.player.x * this.cellSize;
                const playerY = this.player.y * this.cellSize;
                
                // C√≠rculo azul simples para o her√≥i
                const playerGradient = this.ctx.createRadialGradient(
                    playerX, playerY, 0,
                    playerX, playerY, this.cellSize * 0.4
                );
                playerGradient.addColorStop(0, '#60a5fa');
                playerGradient.addColorStop(0.6, '#3b82f6');
                playerGradient.addColorStop(1, '#1d4ed8');
                
                this.ctx.fillStyle = playerGradient;
                this.ctx.beginPath();
                this.ctx.arc(playerX, playerY, this.cellSize * 0.35, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Borda do her√≥i
                this.ctx.strokeStyle = '#1e40af';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // √çcone do her√≥i (‚öîÔ∏è)
                this.ctx.font = `${this.cellSize * 0.4}px Arial`;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('‚öîÔ∏è', playerX, playerY);
                
                this.ctx.restore();

                // üêÇüí™ DESENHAR BOSS CHEFE√ÉO - MINOTAURO LEND√ÅRIO CENTRALIZADO
                this.ctx.save();
                
                // Efeitos visuais baseados no estado do boss
                let shadowColor, shadowBlur, glowIntensity;
                switch(this.minotaur.state) {
                    case 'ATTACK':
                        shadowColor = '#dc2626'; // Vermelho intenso
                        shadowBlur = 35;
                        glowIntensity = 1.2;
                        break;
                    case 'CHASE':
                        shadowColor = '#ef4444'; // Vermelho
                        shadowBlur = 25;
                        glowIntensity = 1.0;
                        break;
                    case 'HUNT':
                        shadowColor = '#f59e0b'; // Laranja
                        shadowBlur = 20;
                        glowIntensity = 0.8;
                        break;
                    default:
                        shadowColor = '#d97706'; // Laranja escuro
                        shadowBlur = 15;
                        glowIntensity = 0.6;
                }
                
                this.ctx.shadowColor = shadowColor;
                this.ctx.shadowBlur = shadowBlur;
                
                const minotaurX = offsetX + (this.minotaur.x * this.cellSize);
                const minotaurY = offsetY + (this.minotaur.y * this.cellSize);
                
                // Debug - verificar se est√° dentro da tela
                if (Math.random() < 0.005) { // Log apenas raramente
                    console.log(`üé® Desenhando Minotauro: x=${minotaurX.toFixed(1)}, y=${minotaurY.toFixed(1)}, cellSize=${this.cellSize}`);
                }
                
                // C√≠rculo laranja/vermelho para o minotauro
                const minotaurGradient = this.ctx.createRadialGradient(
                    minotaurX, minotaurY, 0,
                    minotaurX, minotaurY, this.cellSize * 0.4
                );
                
                // Gradiente din√¢mico baseado no estado do boss
                if (this.minotaur.state === 'ATTACK') {
                    // Vermelho intenso - PERIGO M√ÅXIMO!
                    minotaurGradient.addColorStop(0, '#fecaca');
                    minotaurGradient.addColorStop(0.4, '#ef4444');
                    minotaurGradient.addColorStop(0.8, '#dc2626');
                    minotaurGradient.addColorStop(1, '#991b1b');
                } else if (this.minotaur.state === 'CHASE') {
                    // Vermelho m√©dio - ALERTA!
                    minotaurGradient.addColorStop(0, '#fca5a5');
                    minotaurGradient.addColorStop(0.6, '#ef4444');
                    minotaurGradient.addColorStop(1, '#dc2626');
                } else if (this.minotaur.state === 'HUNT') {
                    // Laranja intenso - PERSEGUI√á√ÉO
                    minotaurGradient.addColorStop(0, '#fed7aa');
                    minotaurGradient.addColorStop(0.6, '#f59e0b');
                    minotaurGradient.addColorStop(1, '#d97706');
                } else {
                    // Laranja normal - PATRULHA
                    minotaurGradient.addColorStop(0, '#fcd34d');
                    minotaurGradient.addColorStop(0.6, '#f59e0b');
                    minotaurGradient.addColorStop(1, '#d97706');
                }
                
                this.ctx.fillStyle = minotaurGradient;
                this.ctx.beginPath();
                
                // Boss fica maior e mais imponente com os n√≠veis
                const bossSize = this.cellSize * (0.4 + (this.level * 0.02)); // Cresce 2% por n√≠vel
                this.ctx.arc(minotaurX, minotaurY, bossSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Borda do boss mais grossa e din√¢mica
                const borderColors = {
                    'ATTACK': '#991b1b',
                    'CHASE': '#dc2626',
                    'HUNT': '#d97706',
                    'PATROL': '#92400e'
                };
                
                this.ctx.strokeStyle = borderColors[this.minotaur.state] || '#d97706';
                this.ctx.lineWidth = this.minotaur.state === 'ATTACK' ? 4 : 3;
                this.ctx.stroke();
                
                // Anel adicional para estados perigosos
                if (this.minotaur.state === 'ATTACK' || this.minotaur.state === 'CHASE') {
                    this.ctx.beginPath();
                    this.ctx.arc(minotaurX, minotaurY, bossSize + 3, 0, Math.PI * 2);
                    this.ctx.strokeStyle = this.minotaur.state === 'ATTACK' ? '#fca5a5' : '#fed7aa';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // üêÇüí™ √çCONE DO BOSS CHEFE√ÉO LEND√ÅRIO
                const bossFontSize = this.cellSize * (0.5 + (this.level * 0.01)); // Cresce com n√≠vel
                this.ctx.font = `${bossFontSize}px Arial`;
                this.ctx.fillStyle = this.minotaur.state === 'ATTACK' ? '#ffffff' : '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Efeito de pulsa√ß√£o para estados perigosos
                if (this.minotaur.state === 'ATTACK') {
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.1; // Pulsa√ß√£o r√°pida
                    this.ctx.save();
                    this.ctx.scale(pulse, pulse);
                    this.ctx.fillText('üêÇ', minotaurX / pulse, minotaurY / pulse);
                    this.ctx.restore();
                } else {
                    this.ctx.fillText('üêÇ', minotaurX, minotaurY);
                }
                
                this.ctx.restore();

                // Efeito de ilumina√ß√£o removido para visual mais limpo
            }

            showHelp() {
                this.playSound('buttonClick'); // üîä Som de clique
                alert(`‚ùì Como Jogar - Labirinto de Creta:

üéØ OBJETIVO:
‚Ä¢ Escape do labirinto sem ser capturado pelo Minotauro

üéÆ CONTROLES:
‚Ä¢ WASD ou Setas: Mover Teseu
‚Ä¢ SHIFT: Correr (2x mais r√°pido)
‚Ä¢ SPACE: Ativar/desativar Fio de Ariadne
‚Ä¢ ESC: Voltar ao menu

üßµ FIO DE ARIADNE:
‚Ä¢ Deixa um rastro dourado do seu caminho
‚Ä¢ Use para n√£o se perder no labirinto
‚Ä¢ Ative/desative com SPACE

üêÇ MINOTAURO:
‚Ä¢ Boss lend√°rio que patrulha o labirinto
‚Ä¢ Evite ser capturado por ele!
‚Ä¢ Estados: Patrulha, Ca√ßa, Ataque

üîä √ÅUDIO:
‚Ä¢ Trilha sonora din√¢mica
‚Ä¢ Efeitos sonoros imersivos
‚Ä¢ M√∫sica muda com as situa√ß√µes

üèÜ DICAS:
‚Ä¢ Use SHIFT para correr quando necess√°rio
‚Ä¢ O Fio de Ariadne ajuda na navega√ß√£o
‚Ä¢ Observe o comportamento do Minotauro
‚Ä¢ Escute os sons para antecipar perigos`);
            }

            showSettings() {
                alert(`‚öôÔ∏è Configura√ß√µes - Labirinto de Creta:

üéÆ CONTROLES:
‚Ä¢ WASD: Movimento principal
‚Ä¢ Setas: Movimento alternativo
‚Ä¢ SHIFT: Corrida (dobra velocidade)
‚Ä¢ SPACE: Fio de Ariadne
‚Ä¢ ESC: Menu

üé® GR√ÅFICOS:
‚Ä¢ Ilumina√ß√£o din√¢mica: Ativada
‚Ä¢ Efeitos visuais: Ativados
‚Ä¢ Responsivo: Sim

üîä √ÅUDIO:
‚Ä¢ Sistema de √°udio ser√° implementado em breve

üì± COMPATIBILIDADE:
‚Ä¢ Desktop: Total
‚Ä¢ Mobile: Parcial (sem teclado)`);
            }
        }

        // Inicializar o jogo quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üèõÔ∏è Labirinto de Creta - Inicializando...');
            const game = new LabirintoDeCreta();
            game.init();
            
            // Tornar dispon√≠vel globalmente para debug
            window.game = game;
        });

        // Tratamento de erros
        window.addEventListener('error', (e) => {
            console.error('üö® Erro no jogo:', e.error);
        });
    </script>
</body>
</html>