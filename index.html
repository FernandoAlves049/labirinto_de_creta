<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèõÔ∏è Labirinto de Creta</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', 'Arial', sans-serif;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 53, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(102, 126, 234, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 60% 60%, rgba(50, 205, 50, 0.15) 0%, transparent 50%),
                linear-gradient(135deg, #1e3a8a 0%, #3b82f6 25%, #06b6d4 50%, #10b981 75%, #f59e0b 100%);
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.8" fill="%23ffd700" opacity="0.4"/><circle cx="12" cy="8" r="0.5" fill="%23fff" opacity="0.3"/><circle cx="18" cy="15" r="0.6" fill="%23ff6b35" opacity="0.2"/><circle cx="5" cy="18" r="0.4" fill="%2367eea" opacity="0.25"/></pattern></defs><rect width="100" height="100" fill="url(%23stars)"/></svg>') repeat;
            pointer-events: none;
            z-index: -1;
            animation: starfield 60s linear infinite;
        }

        @keyframes starfield {
            from { transform: translateY(0px); }
            to { transform: translateY(-100px); }
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            transition: all 0.5s ease-in-out;
        }

        .screen.active {
            display: flex;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Tela de Loading */
        .loading-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 30px;
            padding: 3rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: floatingGlow 4s ease-in-out infinite alternate;
        }

        @keyframes floatingGlow {
            0% { 
                transform: translateY(0px) rotate(0deg);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 30px rgba(255, 215, 0, 0.2);
            }
            100% { 
                transform: translateY(-10px) rotate(0.5deg);
                box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4), 0 0 50px rgba(255, 215, 0, 0.4);
            }
        }

        .logo-loading {
            margin-bottom: 3rem;
            position: relative;
        }

        .logo-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
            display: block;
            animation: iconFloat 3s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
            transform-style: preserve-3d;
        }

        @keyframes iconFloat {
            0%, 100% { 
                transform: translateY(0px) rotateY(0deg);
                text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: translateY(-15px) rotateY(10deg);
                text-shadow: 0 0 50px rgba(255, 215, 0, 1);
            }
        }

        .logo-text {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ff6b35, #f7931e, #ffd700);
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            animation: textShimmer 3s ease-in-out infinite, textGlow 2s ease-in-out infinite alternate;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
        }

        @keyframes textShimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes textGlow {
            from { filter: brightness(1) contrast(1); }
            to { filter: brightness(1.3) contrast(1.1); }
        }

        .loading-bar-container {
            width: 350px;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 15px;
            overflow: hidden;
            margin: 2rem auto;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 4px 20px rgba(255, 215, 0, 0.2);
        }

        .loading-bar-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: scanLine 2s linear infinite;
        }

        @keyframes scanLine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, 
                #ff6b35 0%, 
                #f7931e 25%, 
                #ffd700 50%, 
                #ffed4e 75%, 
                #ffd700 100%
            );
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.5s ease-out;
            animation: progressShimmer 2s linear infinite;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }

        @keyframes progressShimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .loading-text {
            font-size: 1.2rem;
            margin-top: 1rem;
            opacity: 0.8;
        }

        /* Tela de Menu */
        .menu-container {
            text-align: center;
            max-width: 600px;
            padding: 3rem;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 30px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .menu-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(255, 215, 0, 0.1), transparent, rgba(255, 107, 107, 0.1), transparent);
            animation: rotateBackground 20s linear infinite;
            z-index: -1;
        }

        @keyframes rotateBackground {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .menu-header {
            margin-bottom: 3rem;
            position: relative;
        }

        .logo-title {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ff6b35, #f7931e, #ffd700);
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 1rem;
            animation: titlePulse 4s ease-in-out infinite, textShimmer 3s ease-in-out infinite;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            letter-spacing: 3px;
            transform-style: preserve-3d;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1) rotateX(0deg); }
            50% { transform: scale(1.05) rotateX(5deg); }
        }

        .logo-subtitle {
            font-size: 1.4rem;
            font-weight: 400;
            color: #ffd700;
            opacity: 0.9;
            margin-bottom: 2rem;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: subtitleFloat 3s ease-in-out infinite alternate;
            letter-spacing: 1px;
        }

        @keyframes subtitleFloat {
            from { transform: translateY(0px); opacity: 0.9; }
            to { transform: translateY(-5px); opacity: 1; }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            padding: 1.2rem 2.5rem;
            border: none;
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-height: 70px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(20px);
            border: 2px solid transparent;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateY(-5px) scale(1.02);
            filter: brightness(1.1);
        }

        .menu-btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #ff6b35, #f7931e, #ffd700);
            background-size: 200% 200%;
            color: white;
            box-shadow: 
                0 8px 25px rgba(255, 107, 53, 0.4),
                0 4px 15px rgba(247, 147, 30, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.3);
            animation: primaryGlow 3s ease-in-out infinite;
        }

        @keyframes primaryGlow {
            0%, 100% { 
                background-position: 0% 50%;
                box-shadow: 
                    0 8px 25px rgba(255, 107, 53, 0.4),
                    0 4px 15px rgba(247, 147, 30, 0.3),
                    0 0 30px rgba(255, 215, 0, 0.2);
            }
            50% { 
                background-position: 100% 50%;
                box-shadow: 
                    0 12px 35px rgba(255, 107, 53, 0.6),
                    0 6px 20px rgba(247, 147, 30, 0.5),
                    0 0 50px rgba(255, 215, 0, 0.4);
            }
        }

        .menu-btn.primary:hover {
            box-shadow: 
                0 15px 40px rgba(255, 107, 53, 0.6),
                0 8px 25px rgba(247, 147, 30, 0.5),
                0 0 60px rgba(255, 215, 0, 0.5);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            background-size: 200% 200%;
            color: white;
            box-shadow: 
                0 8px 25px rgba(102, 126, 234, 0.4),
                0 4px 15px rgba(118, 75, 162, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.3);
            animation: secondaryGlow 4s ease-in-out infinite;
        }

        @keyframes secondaryGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .menu-btn.secondary:hover {
            box-shadow: 
                0 15px 40px rgba(102, 126, 234, 0.6),
                0 8px 25px rgba(118, 75, 162, 0.5);
        }

        .menu-btn.tertiary {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(30px);
            box-shadow: 
                0 8px 25px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .menu-btn.tertiary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 
                0 15px 40px rgba(255, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .menu-footer {
            font-size: 1rem;
            opacity: 0.8;
            line-height: 1.6;
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 15px;
            backdrop-filter: blur(20px);
        }

        .controls-hint {
            color: #ffd700;
            font-weight: 500;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 5px rgba(255, 215, 0, 0.3);
        }

        .version-info {
            color: #ccc;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Tela de Jogo */
        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(180deg, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(0, 0, 0, 0.7) 70%, 
                transparent 100%
            );
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .hud-left, .hud-right {
            display: flex;
            gap: 2rem;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.8rem 1.2rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .hud-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        .hud-label {
            font-size: 0.8rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #ccc;
        }

        .hud-value {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1.1rem;
            color: #ffd700;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: valueGlow 2s ease-in-out infinite alternate;
        }

        @keyframes valueGlow {
            from { text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 2px 20px rgba(255, 215, 0, 0.8); }
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 2px 15px rgba(255, 215, 0, 0.6);
            letter-spacing: 2px;
            animation: titleShine 3s ease-in-out infinite;
        }

        @keyframes titleShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .game-area {
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 80px 15px 15px;
            position: relative;
        }

        .game-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 70%, rgba(255, 215, 0, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 70% 30%, rgba(59, 130, 246, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        #game-canvas {
            border: 3px solid #ffd700;
            border-radius: 15px;
            background: linear-gradient(145deg, #1e40af, #1e3a8a);
            box-shadow: 
                0 0 60px rgba(255, 215, 0, 0.5),
                0 20px 60px rgba(59, 130, 246, 0.3),
                0 0 100px rgba(16, 185, 129, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
            position: relative;
            transition: all 0.3s ease;
        }

        #game-canvas:hover {
            box-shadow: 
                0 0 80px rgba(255, 215, 0, 0.5),
                0 25px 80px rgba(0, 0, 0, 0.6),
                inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #game-canvas::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #667eea, #ffd700);
            background-size: 300% 300%;
            border-radius: 18px;
            z-index: -1;
            animation: borderGlow 4s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at center, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: overlayFade 0.5s ease-out;
        }

        @keyframes overlayFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: 
                linear-gradient(145deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 25px;
            padding: 3rem;
            text-align: center;
            min-width: 400px;
            max-width: 600px;
            backdrop-filter: blur(30px);
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(255, 215, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
            position: relative;
            animation: modalSlideIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes modalSlideIn {
            from { 
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #667eea, #ffd700);
            background-size: 300% 300%;
            border-radius: 27px;
            z-index: -1;
            animation: modalBorderGlow 4s ease-in-out infinite;
        }

        @keyframes modalBorderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 2.2rem;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 1.5rem;
            text-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
            letter-spacing: 2px;
            animation: modalTitleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes modalTitleGlow {
            from { 
                text-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 6px 25px rgba(255, 215, 0, 0.9);
                transform: scale(1.02);
            }
        }

        .modal-content {
            margin-bottom: 2.5rem;
            line-height: 1.7;
            font-size: 1.1rem;
            color: #e0e0e0;
        }

        .modal-content p {
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            border: 2px solid transparent;
            backdrop-filter: blur(20px);
        }

        .modal-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .modal-btn:hover::before {
            left: 100%;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
            border-color: rgba(255, 107, 53, 0.3);
        }

        .modal-btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            border-color: rgba(102, 126, 234, 0.3);
        }

        .modal-btn.tertiary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
        }

        .modal-btn:hover {
            transform: translateY(-3px) scale(1.05);
            filter: brightness(1.1);
        }

        .modal-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .victory-stats {
            margin: 2rem 0;
            padding: 2rem;
            background: 
                linear-gradient(145deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 107, 53, 0.1) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.8rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 215, 0, 0.4);
            transform: translateX(5px);
        }

        .stat-label {
            font-size: 1rem;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            color: #ffd700;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
            animation: statGlow 2s ease-in-out infinite alternate;
        }

        @keyframes statGlow {
            from { text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 4px 20px rgba(255, 215, 0, 0.8); }
        }

        /* Responsivo */
        @media (max-width: 768px) {
            .game-hud {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .hud-left, .hud-right {
                display: flex;
                gap: 0.8rem;
                justify-content: center;
                flex-wrap: wrap;
            }

            .hud-item {
                padding: 0.6rem 1rem;
                min-width: 80px;
            }

            .game-title {
                font-size: 1.4rem;
                text-align: center;
            }

            #game-canvas {
                width: 90vw;
                height: auto;
                max-width: 400px;
            }

            .menu-container {
                padding: 2rem 1rem;
                max-width: 95%;
                margin: 0 10px;
            }

            .logo-title {
                font-size: 2.5rem;
            }

            .logo-icon {
                font-size: 4rem;
            }

            .menu-btn {
                padding: 1rem 1.5rem;
                font-size: 1rem;
                min-height: 60px;
            }

            .modal {
                min-width: 320px;
                max-width: 90%;
                padding: 2rem 1.5rem;
                margin: 0 20px;
            }

            .modal-title {
                font-size: 1.8rem;
            }

            .modal-actions {
                flex-direction: column;
                gap: 1rem;
            }

            .modal-btn {
                width: 100%;
                padding: 1rem;
            }

            .loading-bar-container {
                width: 280px;
            }

            .game-area {
                padding: 100px 8px 15px;
            }

            .stat-item {
                padding: 0.6rem 1rem;
                margin: 0.8rem 0;
            }
        }

        @media (max-width: 480px) {
            .menu-container {
                padding: 1.5rem 0.8rem;
            }

            .logo-title {
                font-size: 2rem;
            }

            .logo-subtitle {
                font-size: 1.1rem;
            }

            .hud-left, .hud-right {
                gap: 0.5rem;
            }

            .hud-item {
                padding: 0.5rem 0.8rem;
                min-width: 70px;
            }

            .hud-label {
                font-size: 0.7rem;
            }

            .hud-value {
                font-size: 1rem;
            }

            .modal {
                padding: 1.5rem 1rem;
            }

            .modal-title {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Tela de Loading -->
    <div id="loading-screen" class="screen active">
        <div class="loading-container">
            <div class="logo-loading">
                <div class="logo-icon">üèõÔ∏è</div>
                <h1 class="logo-text">Labirinto de Creta</h1>
            </div>
            <div class="loading-bar-container">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <div class="loading-text" id="loading-text">Inicializando...</div>
            <div class="loading-info">
                <p>üéÆ Preparando o desafio do Minotauro...</p>
            </div>
        </div>
    </div>

    <!-- Tela de Menu -->
    <div id="menu-screen" class="screen">
        <div class="menu-container">
            <div class="menu-header">
                <div class="logo">
                    <div class="logo-icon">üèõÔ∏è</div>
                    <h1 class="logo-title">Labirinto de Creta</h1>
                    <p class="logo-subtitle">O Desafio do Minotauro</p>
                </div>
            </div>
            <div class="menu-buttons">
                <button id="btn-start-game" class="menu-btn primary">
                    <span>‚öîÔ∏è</span>
                    <span>Iniciar Jogo</span>
                </button>
                <button id="btn-help" class="menu-btn secondary">
                    <span>‚ùì</span>
                    <span>Como Jogar</span>
                </button>
                <button id="btn-settings" class="menu-btn tertiary">
                    <span>‚öôÔ∏è</span>
                    <span>Configura√ß√µes</span>
                </button>
            </div>
            <div class="menu-footer">
                <p class="controls-hint">üéÆ WASD para mover ‚Ä¢ SPACE para Fio de Ariadne</p>
                <p class="version-info">v2.1.0 ‚Ä¢ HTML5 Game</p>
            </div>
        </div>
    </div>

    <!-- Tela de Jogo -->
    <div id="game-screen" class="screen">
        <div class="game-hud">
            <div class="hud-left">
                <div class="hud-item">
                    <span class="hud-label">N√≠vel:</span>
                    <span class="hud-value" id="hud-level">1</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">Tempo:</span>
                    <span class="hud-value" id="hud-time">0s</span>
                </div>
            </div>
            <div class="hud-center">
                <h1 class="game-title">üèõÔ∏è Labirinto de Creta</h1>
            </div>
            <div class="hud-right">
                <div class="hud-item">
                    <span class="hud-label">Fio:</span>
                    <span class="hud-value" id="hud-thread">INATIVO</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">Minotauro:</span>
                    <span class="hud-value" id="hud-minotaur">PATRULHA</span>
                </div>
            </div>
        </div>
        <div class="game-area">
            <canvas id="game-canvas" width="600" height="450"></canvas>
        </div>
    </div>

    <!-- Overlay de Game Over -->
    <div id="gameover-overlay" class="overlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üíÄ Capturado!</h2>
            </div>
            <div class="modal-content">
                <p>O Minotauro te capturou! Tente novamente.</p>
            </div>
            <div class="modal-actions">
                <button id="btn-retry" class="modal-btn primary">üîÑ Tentar Novamente</button>
                <button id="btn-menu-from-gameover" class="modal-btn secondary">üè† Menu</button>
            </div>
        </div>
    </div>

    <!-- Overlay de Vit√≥ria -->
    <div id="victory-overlay" class="overlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üéâ N√≠vel Conclu√≠do!</h2>
            </div>
            <div class="modal-content">
                <p>Parab√©ns! Voc√™ escapou do labirinto!</p>
                <div class="victory-stats">
                    <div class="stat-item">
                        <span class="stat-label">Tempo:</span>
                        <span class="stat-value" id="victory-time">0s</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">N√≠vel:</span>
                        <span class="stat-value" id="victory-level">1</span>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button id="btn-next-level" class="modal-btn primary">‚û°Ô∏è Pr√≥ximo N√≠vel</button>
                <button id="btn-menu-from-victory" class="modal-btn secondary">üè† Menu</button>
            </div>
        </div>
    </div>

    <script>
        // JOGO LABIRINTO DE CRETA - VERS√ÉO SIMPLIFICADA
        class LabirintoDeCreta {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameState = 'menu';
                this.level = 1;
                this.startTime = 0;
                this.gameTime = 0;
                this.maze = null;
                this.player = { x: 1.5, y: 1.5, r: 0.3, trail: [] };
                this.minotaur = { x: 1.5, y: 1.5, state: 'PATROL', vx: 0, vy: 0, lastDir: 0 };
                this.keys = new Set();
                this.threadActive = false;
                this.cellSize = 30;
                this.lastTime = 0;
                this.gameLoop = null;
            }

            init() {
                this.setupEventListeners();
                this.showLoadingProgress();
            }

            showLoadingProgress() {
                let progress = 0;
                const messages = [
                    'Carregando recursos...',
                    'Configurando labirinto...',
                    'Preparando Minotauro...',
                    'Afiando espada de Teseu...',
                    'Pronto para a aventura!'
                ];

                const interval = setInterval(() => {
                    progress += 20;
                    document.getElementById('loading-progress').style.width = `${progress}%`;
                    document.getElementById('loading-text').textContent = messages[Math.floor(progress / 20) - 1] || messages[0];

                    if (progress >= 100) {
                        clearInterval(interval);
                        setTimeout(() => this.showScreen('menu'), 1000);
                    }
                }, 500);
            }

            showScreen(screenName) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(`${screenName}-screen`).classList.add('active');
                
                if (screenName === 'game' && !this.canvas) {
                    this.initGame();
                }
            }

            showOverlay(overlayName) {
                document.getElementById(`${overlayName}-overlay`).style.display = 'flex';
            }

            hideOverlay(overlayName) {
                document.getElementById(`${overlayName}-overlay`).style.display = 'none';
            }

            setupEventListeners() {
                // Menu buttons
                document.getElementById('btn-start-game').addEventListener('click', () => {
                    this.startNewGame();
                });

                document.getElementById('btn-help').addEventListener('click', () => {
                    this.showHelp();
                });

                document.getElementById('btn-settings').addEventListener('click', () => {
                    this.showSettings();
                });

                // Game over buttons
                document.getElementById('btn-retry').addEventListener('click', () => {
                    this.hideOverlay('gameover');
                    this.restartLevel();
                });

                document.getElementById('btn-menu-from-gameover').addEventListener('click', () => {
                    this.hideOverlay('gameover');
                    this.showScreen('menu');
                    this.stopGame();
                });

                // Victory buttons
                document.getElementById('btn-next-level').addEventListener('click', () => {
                    this.hideOverlay('victory');
                    this.nextLevel();
                });

                document.getElementById('btn-menu-from-victory').addEventListener('click', () => {
                    this.hideOverlay('victory');
                    this.showScreen('menu');
                    this.stopGame();
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys.add(e.code);
                    if (e.code === 'Escape' && this.gameState === 'playing') {
                        this.showScreen('menu');
                        this.stopGame();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys.delete(e.code);
                });
            }

            initGame() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Ajustar canvas para responsividade
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const maxWidth = container.clientWidth - 40;
                const maxHeight = container.clientHeight - 40;
                
                const aspectRatio = 800 / 600;
                let width = maxWidth;
                let height = width / aspectRatio;
                
                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }
                
                this.canvas.style.width = `${width}px`;
                this.canvas.style.height = `${height}px`;
            }

            startNewGame() {
                this.level = 1;
                this.showScreen('game');
                this.startLevel();
            }

            startLevel() {
                this.generateMaze();
                this.resetPlayer();
                this.resetMinotaur();
                this.startTime = Date.now();
                this.gameTime = 0;
                this.gameState = 'playing';
                
                if (this.gameLoop) {
                    cancelAnimationFrame(this.gameLoop);
                }
                this.gameLoop = requestAnimationFrame((time) => this.update(time));
                
                console.log(`üéÆ N√≠vel ${this.level} iniciado!`);
            }

            generateMaze() {
                const size = Math.min(15 + (this.level - 1) * 2, 25);
                this.maze = {
                    width: size,
                    height: size,
                    walls: []
                };

                // Initialize maze with walls
                for (let y = 0; y < size; y++) {
                    this.maze.walls[y] = [];
                    for (let x = 0; x < size; x++) {
                        this.maze.walls[y][x] = 1;
                    }
                }

                // Create paths using simple algorithm
                this.carveMaze(1, 1);
                
                // Ensure start and end are clear
                this.maze.walls[1][1] = 0;
                this.maze.walls[size - 2][size - 2] = 0;
                
                // Calculate cell size
                this.cellSize = Math.min(this.canvas.width / size, this.canvas.height / size);
            }

            carveMaze(x, y) {
                const dirs = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                dirs.sort(() => Math.random() - 0.5);

                this.maze.walls[y][x] = 0;

                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx > 0 && nx < this.maze.width - 1 && 
                        ny > 0 && ny < this.maze.height - 1 && 
                        this.maze.walls[ny][nx] === 1) {
                        
                        this.maze.walls[y + dy / 2][x + dx / 2] = 0;
                        this.carveMaze(nx, ny);
                    }
                }
            }

            resetPlayer() {
                this.player.x = 1.5;
                this.player.y = 1.5;
                this.player.trail = [];
            }

            resetMinotaur() {
                this.minotaur.x = this.maze.width - 1.5;
                this.minotaur.y = 1.5;
                this.minotaur.state = 'PATROL';
                this.minotaur.vx = 0;
                this.minotaur.vy = 0;
                this.minotaur.lastDir = 0;
            }

            update(currentTime) {
                if (this.gameState !== 'playing') return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.gameTime = Date.now() - this.startTime;

                this.updatePlayer(deltaTime);
                this.updateMinotaur(deltaTime);
                this.checkCollisions();
                this.updateHUD();
                this.render();

                this.gameLoop = requestAnimationFrame((time) => this.update(time));
            }

            updatePlayer(deltaTime) {
                const speed = 0.003;
                let dx = 0, dy = 0;

                if (this.keys.has('KeyW') || this.keys.has('ArrowUp')) dy -= speed * deltaTime;
                if (this.keys.has('KeyS') || this.keys.has('ArrowDown')) dy += speed * deltaTime;
                if (this.keys.has('KeyA') || this.keys.has('ArrowLeft')) dx -= speed * deltaTime;
                if (this.keys.has('KeyD') || this.keys.has('ArrowRight')) dx += speed * deltaTime;

                this.threadActive = this.keys.has('Space');

                // Move player with collision
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;

                if (!this.isWall(newX, this.player.y)) {
                    this.player.x = newX;
                }
                if (!this.isWall(this.player.x, newY)) {
                    this.player.y = newY;
                }

                // Add to trail
                if (this.threadActive && this.player.trail.length % 5 === 0) {
                    this.player.trail.push({
                        x: this.player.x,
                        y: this.player.y
                    });
                    if (this.player.trail.length > 100) {
                        this.player.trail.shift();
                    }
                }
            }

            updateMinotaur(deltaTime) {
                const speed = 0.002;
                
                // Simple AI: move randomly, chase if close
                const distToPlayer = Math.sqrt(
                    Math.pow(this.player.x - this.minotaur.x, 2) + 
                    Math.pow(this.player.y - this.minotaur.y, 2)
                );

                if (distToPlayer < 4 && this.hasLineOfSight()) {
                    this.minotaur.state = 'CHASE';
                    // Move toward player
                    const dx = this.player.x - this.minotaur.x;
                    const dy = this.player.y - this.minotaur.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    this.minotaur.vx = (dx / dist) * speed * deltaTime * 1.5;
                    this.minotaur.vy = (dy / dist) * speed * deltaTime * 1.5;
                } else {
                    this.minotaur.state = 'PATROL';
                    // Random movement
                    this.minotaur.lastDir -= deltaTime;
                    if (this.minotaur.lastDir <= 0) {
                        const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                        const [dx, dy] = dirs[Math.floor(Math.random() * dirs.length)];
                        this.minotaur.vx = dx * speed * deltaTime;
                        this.minotaur.vy = dy * speed * deltaTime;
                        this.minotaur.lastDir = 1000 + Math.random() * 2000;
                    }
                }

                // Move minotaur with collision
                const newX = this.minotaur.x + this.minotaur.vx;
                const newY = this.minotaur.y + this.minotaur.vy;

                if (!this.isWall(newX, this.minotaur.y)) {
                    this.minotaur.x = newX;
                } else {
                    this.minotaur.vx = -this.minotaur.vx;
                }

                if (!this.isWall(this.minotaur.x, newY)) {
                    this.minotaur.y = newY;
                } else {
                    this.minotaur.vy = -this.minotaur.vy;
                }
            }

            hasLineOfSight() {
                // Simplified line of sight
                return Math.random() > 0.3; // 70% chance of seeing player when close
            }

            isWall(x, y) {
                const gx = Math.floor(x);
                const gy = Math.floor(y);
                return this.maze.walls[gy]?.[gx] === 1;
            }

            checkCollisions() {
                // Check win condition
                const exitX = this.maze.width - 2;
                const exitY = this.maze.height - 2;
                
                if (Math.abs(this.player.x - exitX - 0.5) < 0.5 && 
                    Math.abs(this.player.y - exitY - 0.5) < 0.5) {
                    this.gameWon();
                    return;
                }

                // Check minotaur collision
                const dist = Math.sqrt(
                    Math.pow(this.player.x - this.minotaur.x, 2) + 
                    Math.pow(this.player.y - this.minotaur.y, 2)
                );

                if (dist < 0.8) {
                    this.gameOver();
                }
            }

            gameWon() {
                this.gameState = 'won';
                document.getElementById('victory-level').textContent = this.level;
                document.getElementById('victory-time').textContent = `${Math.floor(this.gameTime / 1000)}s`;
                this.showOverlay('victory');
            }

            gameOver() {
                this.gameState = 'gameover';
                this.showOverlay('gameover');
            }

            nextLevel() {
                this.level++;
                this.startLevel();
            }

            restartLevel() {
                this.startLevel();
            }

            stopGame() {
                this.gameState = 'menu';
                if (this.gameLoop) {
                    cancelAnimationFrame(this.gameLoop);
                    this.gameLoop = null;
                }
            }

            updateHUD() {
                document.getElementById('hud-level').textContent = this.level;
                document.getElementById('hud-time').textContent = `${Math.floor(this.gameTime / 1000)}s`;
                document.getElementById('hud-thread').textContent = this.threadActive ? 'ATIVO' : 'INATIVO';
                document.getElementById('hud-minotaur').textContent = this.minotaur.state;
            }

            render() {
                if (!this.ctx || !this.maze) return;

                // Fundo mais claro e colorido
                const backgroundGradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                backgroundGradient.addColorStop(0, '#1e3a8a');
                backgroundGradient.addColorStop(0.5, '#1e40af');
                backgroundGradient.addColorStop(1, '#2563eb');
                this.ctx.fillStyle = backgroundGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw maze com paredes mais claras
                for (let y = 0; y < this.maze.height; y++) {
                    for (let x = 0; x < this.maze.width; x++) {
                        if (this.maze.walls[y][x] === 1) {
                            // Paredes com gradiente dourado
                            const wallGradient = this.ctx.createLinearGradient(
                                x * this.cellSize, y * this.cellSize,
                                (x + 1) * this.cellSize, (y + 1) * this.cellSize
                            );
                            wallGradient.addColorStop(0, '#d97706');
                            wallGradient.addColorStop(0.5, '#f59e0b');
                            wallGradient.addColorStop(1, '#fbbf24');
                            this.ctx.fillStyle = wallGradient;
                            this.ctx.fillRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                            
                            // Adicionar borda mais escura para defini√ß√£o
                            this.ctx.strokeStyle = '#92400e';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                        }
                    }
                }

                // Draw exit com efeito especial
                const exitX = this.maze.width - 2;
                const exitY = this.maze.height - 2;
                
                // Glow da sa√≠da
                this.ctx.save();
                this.ctx.shadowColor = '#10b981';
                this.ctx.shadowBlur = 20;
                
                // Gradiente da sa√≠da
                const exitGradient = this.ctx.createRadialGradient(
                    exitX * this.cellSize + this.cellSize/2,
                    exitY * this.cellSize + this.cellSize/2,
                    0,
                    exitX * this.cellSize + this.cellSize/2,
                    exitY * this.cellSize + this.cellSize/2,
                    this.cellSize/2
                );
                exitGradient.addColorStop(0, '#10b981');
                exitGradient.addColorStop(0.7, '#059669');
                exitGradient.addColorStop(1, '#047857');
                
                this.ctx.fillStyle = exitGradient;
                this.ctx.fillRect(
                    exitX * this.cellSize + 2, 
                    exitY * this.cellSize + 2, 
                    this.cellSize - 4, 
                    this.cellSize - 4
                );
                this.ctx.restore();

                // Draw trail (Fio de Ariadne) com efeito especial
                if (this.threadActive && this.player.trail.length > 1) {
                    this.ctx.save();
                    this.ctx.shadowColor = '#ffd700';
                    this.ctx.shadowBlur = 10;
                    
                    // Criar gradiente para o fio
                    const trailGradient = this.ctx.createLinearGradient(
                        this.player.trail[0].x * this.cellSize,
                        this.player.trail[0].y * this.cellSize,
                        this.player.trail[this.player.trail.length - 1].x * this.cellSize,
                        this.player.trail[this.player.trail.length - 1].y * this.cellSize
                    );
                    trailGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    trailGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.8)');
                    trailGradient.addColorStop(1, 'rgba(255, 215, 0, 1)');
                    
                    this.ctx.strokeStyle = trailGradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        this.player.trail[0].x * this.cellSize, 
                        this.player.trail[0].y * this.cellSize
                    );
                    for (let i = 1; i < this.player.trail.length; i++) {
                        this.ctx.lineTo(
                            this.player.trail[i].x * this.cellSize, 
                            this.player.trail[i].y * this.cellSize
                        );
                    }
                    this.ctx.stroke();
                    this.ctx.restore();
                }

                // Draw player (Teseu) com efeito especial
                this.ctx.save();
                this.ctx.shadowColor = '#60a5fa';
                this.ctx.shadowBlur = 15;
                
                // Gradiente do player
                const playerGradient = this.ctx.createRadialGradient(
                    this.player.x * this.cellSize,
                    this.player.y * this.cellSize,
                    0,
                    this.player.x * this.cellSize,
                    this.player.y * this.cellSize,
                    this.cellSize * 0.4
                );
                playerGradient.addColorStop(0, '#60a5fa');
                playerGradient.addColorStop(0.6, '#3b82f6');
                playerGradient.addColorStop(1, '#1d4ed8');
                
                this.ctx.fillStyle = playerGradient;
                this.ctx.beginPath();
                this.ctx.arc(
                    this.player.x * this.cellSize, 
                    this.player.y * this.cellSize, 
                    this.cellSize * 0.35, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Borda do player
                this.ctx.strokeStyle = '#1e40af';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                this.ctx.restore();

                // Draw minotaur com efeito especial
                this.ctx.save();
                const isChasing = this.minotaur.state === 'CHASE';
                this.ctx.shadowColor = isChasing ? '#ef4444' : '#f59e0b';
                this.ctx.shadowBlur = isChasing ? 25 : 15;
                
                // Gradiente do minotaur
                const minotaurGradient = this.ctx.createRadialGradient(
                    this.minotaur.x * this.cellSize,
                    this.minotaur.y * this.cellSize,
                    0,
                    this.minotaur.x * this.cellSize,
                    this.minotaur.y * this.cellSize,
                    this.cellSize * 0.4
                );
                
                if (isChasing) {
                    minotaurGradient.addColorStop(0, '#fca5a5');
                    minotaurGradient.addColorStop(0.6, '#ef4444');
                    minotaurGradient.addColorStop(1, '#dc2626');
                } else {
                    minotaurGradient.addColorStop(0, '#fcd34d');
                    minotaurGradient.addColorStop(0.6, '#f59e0b');
                    minotaurGradient.addColorStop(1, '#d97706');
                }
                
                this.ctx.fillStyle = minotaurGradient;
                this.ctx.beginPath();
                this.ctx.arc(
                    this.minotaur.x * this.cellSize, 
                    this.minotaur.y * this.cellSize, 
                    this.cellSize * 0.38, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Borda do minotaur
                this.ctx.strokeStyle = isChasing ? '#991b1b' : '#92400e';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                this.ctx.restore();

                // Efeito de ilumina√ß√£o sutil e colorido
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(0, 0, 20, 0.15)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.globalCompositeOperation = 'destination-out';

                const lightRadius = this.cellSize * 6;
                const lightGradient = this.ctx.createRadialGradient(
                    this.player.x * this.cellSize, 
                    this.player.y * this.cellSize, 
                    lightRadius * 0.2,
                    this.player.x * this.cellSize, 
                    this.player.y * this.cellSize, 
                    lightRadius
                );
                lightGradient.addColorStop(0, 'rgba(0, 0, 20, 0.8)');
                lightGradient.addColorStop(0.4, 'rgba(0, 0, 20, 0.3)');
                lightGradient.addColorStop(1, 'rgba(0, 0, 20, 0)');
                
                this.ctx.fillStyle = lightGradient;
                this.ctx.beginPath();
                this.ctx.arc(
                    this.player.x * this.cellSize, 
                    this.player.y * this.cellSize, 
                    lightRadius, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                this.ctx.restore();
            }

            showHelp() {
                alert(`‚ùì Como Jogar - Labirinto de Creta:

üéØ OBJETIVO:
‚Ä¢ Escape do labirinto sem ser capturado pelo Minotauro

üéÆ CONTROLES:
‚Ä¢ WASD ou Setas: Mover Teseu
‚Ä¢ SPACE: Ativar/desativar Fio de Ariadne
‚Ä¢ ESC: Voltar ao menu

üßµ FIO DE ARIADNE:
‚Ä¢ Deixa um rastro dourado do seu caminho
‚Ä¢ Use para n√£o se perder no labirinto

üêÇ MINOTAURO:
‚Ä¢ Patrulha o labirinto procurando por voc√™
‚Ä¢ Fica vermelho e mais r√°pido quando te persegue
‚Ä¢ Evite ser capturado!

üèÜ DICAS:
‚Ä¢ Use as paredes para se esconder
‚Ä¢ O Fio de Ariadne te ajuda a voltar
‚Ä¢ Seja r√°pido mas cuidadoso!
‚Ä¢ A sa√≠da fica no canto inferior direito (verde)`);
            }

            showSettings() {
                alert(`‚öôÔ∏è Configura√ß√µes - Labirinto de Creta:

üéÆ CONTROLES:
‚Ä¢ WASD: Movimento principal
‚Ä¢ Setas: Movimento alternativo  
‚Ä¢ SPACE: Fio de Ariadne
‚Ä¢ ESC: Menu

üé® GR√ÅFICOS:
‚Ä¢ Ilumina√ß√£o din√¢mica: Ativada
‚Ä¢ Efeitos visuais: Ativados
‚Ä¢ Responsivo: Sim

üîä √ÅUDIO:
‚Ä¢ Sistema de √°udio ser√° implementado em breve

üì± COMPATIBILIDADE:
‚Ä¢ Desktop: Total
‚Ä¢ Mobile: Parcial (sem teclado)`);
            }
        }

        // Inicializar o jogo quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üèõÔ∏è Labirinto de Creta - Inicializando...');
            const game = new LabirintoDeCreta();
            game.init();
            
            // Tornar dispon√≠vel globalmente para debug
            window.game = game;
        });

        // Tratamento de erros
        window.addEventListener('error', (e) => {
            console.error('üö® Erro no jogo:', e.error);
        });
    </script>
</body>
</html>